<!doctype html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Culebra Cósmica</title>

  <style>
    :root{
      --bg0:#05060d;
      --bg1:#0b1020;
      --bg2:#020617;

      --panel: rgba(15, 23, 42, 0.82);
      --stroke: rgba(148, 163, 184, 0.18);

      --text:#f8fafc;
      --muted:#cbd5f5;

      --accent:#38bdf8;
      --accent2:#a78bfa;

      --gold:#facc15;
      --green:#22c55e;
      --red:#fb7185;
      --amber:#f59e0b;
    }

    *{
      box-sizing:border-box;
      margin:0;
      padding:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, "Helvetica Neue", Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    html, body{ height:100%; width:100%; }

    body{
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      color:var(--text);
      padding:16px;
      overflow:hidden;
      touch-action:none;
      -webkit-user-select:none;
      user-select:none;

      background:
        radial-gradient(1100px 520px at 18% 12%, rgba(56,189,248,0.18), transparent 60%),
        radial-gradient(900px 500px at 82% 18%, rgba(167,139,250,0.18), transparent 60%),
        radial-gradient(1000px 600px at 50% 88%, rgba(250,204,21,0.10), transparent 60%),
        linear-gradient(180deg, var(--bg1), var(--bg2));
    }

    #app{
      position:relative;
      width:100%;
      display:flex;
      justify-content:center;
    }

    .game-wrapper{
      width:100%;
      max-width:1200px;
      background: linear-gradient(180deg, var(--panel), rgba(15,23,42,0.68));
      border:1px solid var(--stroke);
      border-radius:26px;
      box-shadow:
        0 26px 70px rgba(0,0,0,.48),
        inset 0 1px 0 rgba(255,255,255,0.06);
      padding:16px 16px 18px;
      display:flex;
      flex-direction:column;
      gap:12px;
      position:relative;
      overflow:hidden;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }

    .game-wrapper::before{
      content:"";
      position:absolute;
      inset:-40% -30%;
      background: linear-gradient(120deg,
        transparent 35%,
        rgba(255,255,255,0.05) 46%,
        transparent 58%);
      transform: rotate(10deg);
      pointer-events:none;
    }

    .game-container{
      background:
        radial-gradient(900px 260px at 50% 0%, rgba(56,189,248,0.14), transparent 60%),
        linear-gradient(180deg, rgba(2,6,23,0.60), rgba(2,6,23,0.35));
      border-radius:22px;
      overflow:hidden;
      padding:0;
      box-shadow:
        inset 0 0 0 1px rgba(15,23,42,.35),
        0 20px 40px rgba(0,0,0,0.28);
      display:flex;
      flex-direction:column;
      gap:8px;
      position:relative;
    }

    /* HUD overlay (no reduce el tamaño del juego) */
    .game-container .topbar,
    .game-container .hudrow{
      position:absolute;
      left:12px;
      right:12px;
      z-index:8;
      pointer-events:none;
    }
    .game-container .topbar{ top:12px; }
    .game-container .hudrow{ top:74px; }

    .game-container .topbar .btn,
    .game-container .topbar button,
    .game-container .hudrow .chip{
      pointer-events:auto;
    }

    .topbar{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
      position:relative;
      z-index:2;
    }

    .brand{
      display:flex;
      align-items:center;
      gap:10px;
      min-width:0;
      flex:1 1 auto;
    }

    .logo{
      width:40px;
      height:40px;
      border-radius:14px;
      display:grid;
      place-items:center;
      background:
        radial-gradient(20px 20px at 30% 30%, rgba(255,255,255,0.28), transparent 60%),
        linear-gradient(135deg, rgba(56,189,248,0.95), rgba(167,139,250,0.95));
      box-shadow: 0 10px 22px rgba(0,0,0,0.35);
      border:1px solid rgba(255,255,255,0.18);
      font-weight: 1000;
      letter-spacing:.4px;
    }

    .brand h1{
      font-size:16px;
      font-weight:900;
      letter-spacing:.2px;
      margin-bottom:1px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width:44vw;
    }
    .brand p{
      font-size:12px;
      color: rgba(203,213,245,0.92);
      line-height:1.25;
      max-width:560px;
    }

    .actions{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:nowrap;
      justify-content:flex-end;
      overflow-x:auto;
      -webkit-overflow-scrolling:touch;
      scrollbar-width:none;
      max-width:56vw;
    }
    .actions::-webkit-scrollbar{ display:none; }

    .btn{
      border:none;
      border-radius:14px;
      padding:9px 12px;
      font-size:12px;
      font-weight:900;
      cursor:pointer;
      color:var(--text);
      background: rgba(255,255,255,0.10);
      border:1px solid rgba(255,255,255,0.14);
      transition:transform .12s ease, filter .12s ease, background .12s ease;
      user-select:none;
      display:inline-flex;
      align-items:center;
      gap:8px;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      flex:0 0 auto;
    }
    .btn:hover{ transform: translateY(-1px); filter: brightness(1.03); background: rgba(255,255,255,0.12); }
    .btn:active{ transform: translateY(1px); }

    .btn-volver{
      background: rgba(226,232,240,0.90);
      color:#0b1020;
      border:1px solid rgba(255,255,255,0.35);
    }

    .btn-primary{
      background: linear-gradient(135deg, rgba(56,189,248,0.92), rgba(167,139,250,0.92));
      border:1px solid rgba(255,255,255,0.20);
    }

    .btn-danger{
      background: linear-gradient(135deg, rgba(251,113,133,0.92), rgba(245,158,11,0.70));
      border:1px solid rgba(255,255,255,0.18);
    }

    .hudrow{
      display:flex;
      align-items:center;
      justify-content:flex-start;
      gap:10px;
      flex-wrap:nowrap;
      position:relative;
      z-index:2;
      overflow:hidden;
    }

    .chip{
      display:flex;
      align-items:center;
      gap:8px;
      padding:6px 8px;
      border-radius:12px;
      background: rgba(2,6,23,0.45);
      border:1px solid rgba(148,163,184,0.18);
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.05);
      font-size:11px;
      font-weight:900;
      color: rgba(248,250,252,0.95);
      white-space:nowrap;
    }
    .chip b{ color: var(--gold); }

    canvas{
      display:block;
      margin:0 auto;
      width:100%;
      max-width:none;
      height:100%;
      border-radius:18px;
      background: radial-gradient(820px 260px at 50% 10%, rgba(255,255,255,0.08), transparent 60%),
                  linear-gradient(180deg, #0b1224, #020617);
      touch-action:none;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.06);
    }

    .help{
      display:none !important;
    }

    @media (max-width: 820px){
      body{ padding:0; align-items:stretch; justify-content:stretch; }
      #app{
        position:fixed;
        inset:0;
        padding: env(safe-area-inset-top) env(safe-area-inset-right)
                 env(safe-area-inset-bottom) env(safe-area-inset-left);
      }
      .game-wrapper{
        max-width:none;
        width:100%;
        height:100%;
        border-radius:0;
        box-shadow:none;
        padding:12px;
        border-left:0; border-right:0;
      }
      .brand p{ display:none; }
      .game-container{ flex:1; }
    }

    @media (max-width: 420px){
      .brand h1{ font-size:14px; max-width:52vw; }
      .actions{ max-width:48vw; }
    }
  </style>
</head>

<body>
  <div id="app">
    <div class="game-wrapper">
      <div class="game-container" id="gameContainer">
        <div class="topbar">
          <div class="brand" aria-label="Encabezado del juego">
            <div class="logo" aria-hidden="true">CC</div>
            <div>
              <h1>Culebra Cósmica</h1>
              <p>Come monedas, evita chocar y sube de nivel. Más nivel = más velocidad y más obstáculos.</p>
            </div>
          </div>

          <div class="actions">
            <button class="btn btn-volver" id="btnBack" type="button">⬅ Volver</button>
            <button class="btn btn-primary" id="btnRestartTop" type="button" style="display:none;">↻ Reintentar</button>
          </div>
        </div>

        <div class="hudrow">
          <div class="chip">Puntaje: <b id="hudScore">0</b></div>
          <div class="chip">Nivel: <b id="hudLevel">1</b></div>
          <div class="chip">Monedas: <b id="hudCoins">0</b></div>
        </div>

        <canvas id="gameCanvas" width="720" height="720"></canvas>

        <div class="help">
          <span>Controles: ← ↑ → ↓ (móvil: desliza). Enter / R para reintentar.</span>
          <button id="btnRestart" class="btn btn-danger">↻ Reintentar</button>
        </div>
      </div>
    </div>
  </div>

  <script>
(() => {
"use strict";

/* ---------------------------------------------------------
 *  DOM / CANVAS
 * --------------------------------------------------------- */
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d", { alpha:true });

const hudScore = document.getElementById("hudScore");
const hudLevel = document.getElementById("hudLevel");
const hudCoins = document.getElementById("hudCoins");
const btnRestart = document.getElementById("btnRestart");
const btnRestartTop = document.getElementById("btnRestartTop");
const btnBack = document.getElementById("btnBack");
let W = canvas.width;
let H = canvas.height;

/* ---------------------------------------------------------
 *  RESPONSIVE (PC cuadrado / móvil rectangular)
 * --------------------------------------------------------- */
const DESKTOP_SIZE = 720;     // PC: canvas cuadrado
const MOBILE_W = 840;         // Móvil: canvas rectangular base
const MOBILE_H = 520;

function isMobile(){
  return Math.min(window.innerWidth, window.innerHeight) <= 900;
}

function setCanvasMode(){
  if(isMobile()){
    canvas.width = MOBILE_W;
    canvas.height = MOBILE_H;
  } else {
    canvas.width = DESKTOP_SIZE;
    canvas.height = DESKTOP_SIZE;
  }
  W = canvas.width;
  H = canvas.height;
  recomputeGeometry();
}

// Ajuste visual para que el canvas NUNCA se desborde (contain)
function applyFit(){
  const container = document.getElementById("gameContainer") || canvas.parentElement;
  const rect = container.getBoundingClientRect();

  const styles = getComputedStyle(container);
  const padX = (parseFloat(styles.paddingLeft||"0") + parseFloat(styles.paddingRight||"0"));
  const padY = (parseFloat(styles.paddingTop||"0") + parseFloat(styles.paddingBottom||"0"));

  const availW = Math.max(0, rect.width - padX);
  const availH = Math.max(0, rect.height - padY);

  const scale = Math.min(availW / canvas.width, availH / canvas.height);

  canvas.style.width  = Math.floor(canvas.width  * scale) + "px";
  canvas.style.height = Math.floor(canvas.height * scale) + "px";
}

// Recalcula canvas + fit ante cambios
function handleResize(){
  const prevMobile = handleResize._wasMobile;
  const nowMobile = isMobile();
  if(prevMobile === undefined || prevMobile !== nowMobile){
    setCanvasMode();
  } else {
    // si no cambió de modo, solo recalcula fit
    W = canvas.width;
    H = canvas.height;
    recomputeGeometry();
  }
  handleResize._wasMobile = nowMobile;
  requestAnimationFrame(applyFit);
}

window.addEventListener("resize", () => setTimeout(handleResize, 60), { passive:true });
window.addEventListener("orientationchange", () => setTimeout(handleResize, 160), { passive:true });

/* ---------------------------------------------------------
 *  CONFIG
 * --------------------------------------------------------- */
const GRID = 24;

// Geometría del tablero (siempre cuadrado)
let TILE = 0;
let BOARD_W = 0;
let BOARD_H = 0;
let boardX = 0;
let boardY = 0;

function recomputeGeometry(){
  TILE = Math.floor(Math.min(W, H) / GRID);
  BOARD_W = TILE * GRID;
  BOARD_H = TILE * GRID;
  boardX = Math.floor((W - BOARD_W) / 2);
  boardY = Math.floor((H - BOARD_H) / 2);
}
const SCORE_PER_COIN = 10;
const LEVEL_EVERY_POINTS = 50;

const BASE_STEP_MS = 135;
const MIN_STEP_MS = 65;

const BANNER_FRAMES = 110;

// Obstáculos (crecen por nivel)
const OBST_BASE = 8;          // cantidad base de “celdas pared”
const OBST_PER_LEVEL = 3;     // celdas adicionales por nivel
const OBST_MAX = 60;          // límite para no saturar

/* ---------------------------------------------------------
 *  UTILS
 * --------------------------------------------------------- */
const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
const rand = (a, b) => a + Math.random() * (b - a);

function roundedRectPath(g, x, y, w, h, r){
  const rr = Math.min(r, w/2, h/2);
  g.beginPath();
  g.moveTo(x+rr, y);
  g.lineTo(x+w-rr, y);
  g.quadraticCurveTo(x+w, y, x+w, y+rr);
  g.lineTo(x+w, y+h-rr);
  g.quadraticCurveTo(x+w, y+h, x+w-rr, y+h);
  g.lineTo(x+rr, y+h);
  g.quadraticCurveTo(x, y+h, x, y+h-rr);
  g.lineTo(x, y+rr);
  g.quadraticCurveTo(x, y, x+rr, y);
  g.closePath();
}

/* ---------------------------------------------------------
 *  AUDIO (FX)
 * --------------------------------------------------------- */
let fxCtx = null;
function getFxCtx(){
  if(!fxCtx){
    const AC = window.AudioContext || window.webkitAudioContext;
    if(AC) fxCtx = new AC();
  }
  return fxCtx;
}

function fxBeep(steps, dur = 0.28, vol = 0.18, type = "square"){
  const ac = getFxCtx();
  if(!ac) return;
  if(ac.state === "suspended") ac.resume();

  const now = ac.currentTime;
  const osc = ac.createOscillator();
  const gain = ac.createGain();

  osc.type = type;
  gain.gain.setValueAtTime(vol, now);

  osc.connect(gain);
  gain.connect(ac.destination);

  for(const s of steps){
    osc.frequency.setValueAtTime(s.freq, now + s.time);
  }

  gain.gain.exponentialRampToValueAtTime(0.001, now + dur);
  osc.start(now);
  osc.stop(now + dur + 0.02);
}

function playFx(kind){
  switch(kind){
    case "coin":
      fxBeep([{time:0.00,freq:900},{time:0.05,freq:1100},{time:0.10,freq:1350}], 0.22, 0.20);
      break;
    case "levelup":
      fxBeep([{time:0.00,freq:600},{time:0.06,freq:800},{time:0.12,freq:1000}], 0.28, 0.18);
      break;
    case "hit":
      fxBeep([{time:0.00,freq:400},{time:0.05,freq:260},{time:0.10,freq:180}], 0.26, 0.20);
      break;
    case "lose": {
      const ac = getFxCtx();
      if(!ac) return;
      if(ac.state === "suspended") ac.resume();

      const now = ac.currentTime;
      const osc = ac.createOscillator();
      const gain = ac.createGain();
      const filter = ac.createBiquadFilter();

      osc.type = "square";
      filter.type = "lowpass";
      filter.frequency.setValueAtTime(1800, now);
      filter.frequency.exponentialRampToValueAtTime(250, now + 0.75);

      gain.gain.setValueAtTime(0.22, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.85);

      osc.connect(filter);
      filter.connect(gain);
      gain.connect(ac.destination);

      osc.frequency.setValueAtTime(520, now);
      osc.frequency.exponentialRampToValueAtTime(110, now + 0.85);

      osc.start(now);
      osc.stop(now + 0.9);
      break;
    }
    default:
      fxBeep([{time:0.00,freq:500},{time:0.07,freq:650}], 0.22, 0.14);
  }
}

/* ---------------------------------------------------------
 *  STATE
 * --------------------------------------------------------- */
const state = {
  frame: 0,
  score: 0,
  coins: 0,
  level: 1,
  playing: true,
  banner: 0,
  shake: 0,
  stepMs: BASE_STEP_MS,

  // “Swoosh” visual cuando sube nivel
  swoosh: 0,     // frames
  swooshFlash: 0 // frames
};

let snake = [];
let dir = { x: 1, y: 0 };
let nextDir = { x: 1, y: 0 };

const coin = {
  x: 0, y: 0,
  r: 11,
  spin: rand(0, Math.PI * 2),
  glow: rand(0.35, 0.85)
};

const walls = [];        // celdas bloqueadas: {x,y}
const particles = [];    // partículas: {x,y,vx,vy,r,life,t,color,glow}

let tickTimer = null;

// Touch swipe
let touchStart = null;

/* ---------------------------------------------------------
 *  PARTICLES
 * --------------------------------------------------------- */
function emitParticles(px, py, count, cfg = {}){
  const {
    minVx = -2.2, maxVx = 2.2,
    minVy = -2.8, maxVy = -0.8,
    minR  = 1.2,  maxR  = 3.0,
    life  = 34,
    gravity = 0.10,
    drag = 0.985,
    color = "#fde047",
    glow = true
  } = cfg;

  for(let i=0;i<count;i++){
    particles.push({
      x: px, y: py,
      vx: rand(minVx, maxVx),
      vy: rand(minVy, maxVy),
      r: rand(minR, maxR),
      life: life + Math.floor(rand(-8, 10)),
      t: 0,
      g: gravity,
      d: drag,
      color,
      glow
    });
  }
}

function updateParticles(){
  for(let i = particles.length-1; i >= 0; i--){
    const p = particles[i];
    p.t++;
    p.vx *= p.d;
    p.vy = (p.vy + p.g) * p.d;
    p.x += p.vx;
    p.y += p.vy;
    if(p.t >= p.life) particles.splice(i, 1);
  }
}

function drawParticles(){
  for(const p of particles){
    const a = 1 - (p.t / p.life);
    ctx.globalAlpha = a;

    if(p.glow){
      ctx.shadowColor = p.color;
      ctx.shadowBlur = 10 * a;
    } else {
      ctx.shadowBlur = 0;
    }

    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
    ctx.fill();

    ctx.shadowBlur = 0;
  }
  ctx.globalAlpha = 1;
}

/* ---------------------------------------------------------
 *  WALLS / OBSTACLES
 * --------------------------------------------------------- */
function wallKey(x,y){ return x + ":" + y; }

function isWallCell(x,y){
  return walls.some(w => w.x===x && w.y===y);
}

function rebuildWallsForLevel(){
  walls.length = 0;

  // cantidad de celdas de pared según nivel
  const target = clamp(OBST_BASE + (state.level-1)*OBST_PER_LEVEL, 0, OBST_MAX);

  const start = snake[0];
  const forbidden = new Set();

  // zona de seguridad alrededor de la cabeza
  for(let dy=-2; dy<=2; dy++){
    for(let dx=-2; dx<=2; dx++){
      const ax = start.x + dx;
      const ay = start.y + dy;
      if(ax>=0 && ay>=0 && ax<GRID && ay<GRID) forbidden.add(wallKey(ax,ay));
    }
  }

  // y alrededor de la cola inicial para no encerrar al inicio
  for(const s of snake){
    forbidden.add(wallKey(s.x,s.y));
  }

  const used = new Set([...forbidden]);

  let tries = 0;
  while(walls.length < target && tries < 2500){
    tries++;

    // preferimos “bloques” que se sientan como muros: prob de 70% de extender desde un muro existente
    let x, y;
    if(walls.length > 0 && Math.random() < 0.7){
      const base = walls[Math.floor(Math.random()*walls.length)];
      const dirs = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
      const d = dirs[Math.floor(Math.random()*dirs.length)];
      x = base.x + d.x;
      y = base.y + d.y;
    } else {
      x = Math.floor(Math.random()*GRID);
      y = Math.floor(Math.random()*GRID);
    }

    if(x<0 || y<0 || x>=GRID || y>=GRID) continue;

    const k = wallKey(x,y);
    if(used.has(k)) continue;

    // evitamos bordes muy cargados para que sea jugable
    if((x===0 || y===0 || x===GRID-1 || y===GRID-1) && Math.random() < 0.55) continue;

    walls.push({x,y});
    used.add(k);
  }
}

/* ---------------------------------------------------------
 *  GAME INIT / RESET
 * --------------------------------------------------------- */
function placeCoin(){
  while(true){
    const cx = Math.floor(Math.random() * GRID);
    const cy = Math.floor(Math.random() * GRID);

    if(snake.some(s => s.x === cx && s.y === cy)) continue;
    if(isWallCell(cx,cy)) continue;

    coin.x = cx;
    coin.y = cy;
    coin.spin = rand(0, Math.PI * 2);
    coin.glow = rand(0.35, 0.85);
    return;
  }
}

function resetGame(){
  state.frame = 0;
  state.score = 0;
  state.coins = 0;
  state.level = 1;
  state.playing = true;
  state.banner = 0;
  state.shake = 0;
  state.stepMs = BASE_STEP_MS;
  state.swoosh = 0;
  state.swooshFlash = 0;

  particles.length = 0;

  snake = [
    {x: Math.floor(GRID*0.5), y: Math.floor(GRID*0.5)},
    {x: Math.floor(GRID*0.5)-1, y: Math.floor(GRID*0.5)},
    {x: Math.floor(GRID*0.5)-2, y: Math.floor(GRID*0.5)}
  ];

  dir = {x:1,y:0};
  nextDir = {x:1,y:0};

  rebuildWallsForLevel();
  placeCoin();

  hudScore.textContent = "0";
  hudLevel.textContent = "1";
  hudCoins.textContent = "0";

  btnRestart.style.display = "none";
  if(btnRestartTop) btnRestartTop.style.display = "none";

  if(tickTimer) clearInterval(tickTimer);
  tickTimer = setInterval(tick, state.stepMs);
}

/* ---------------------------------------------------------
 *  INPUT
 * --------------------------------------------------------- */
function setDir(nx, ny){
  if(nx === -dir.x && ny === -dir.y) return;
  nextDir = { x:nx, y:ny };
}

document.addEventListener("keydown", (e) => {
  if(e.code === "ArrowUp") { e.preventDefault(); setDir(0,-1); }
  if(e.code === "ArrowDown") { e.preventDefault(); setDir(0,1); }
  if(e.code === "ArrowLeft") { e.preventDefault(); setDir(-1,0); }
  if(e.code === "ArrowRight") { e.preventDefault(); setDir(1,0); }

  if(!state.playing && (e.code === "Enter" || e.code === "KeyR")) resetGame();
});

canvas.addEventListener("touchstart", (e) => {
  e.preventDefault();
  const t = e.touches[0];
  touchStart = { x: t.clientX, y: t.clientY };
}, { passive:false });

canvas.addEventListener("touchmove", (e) => {
  e.preventDefault();
  if(!touchStart) return;
  const t = e.touches[0];
  const dx = t.clientX - touchStart.x;
  const dy = t.clientY - touchStart.y;

  if(Math.abs(dx) < 18 && Math.abs(dy) < 18) return;

  if(Math.abs(dx) > Math.abs(dy)){
    setDir(dx > 0 ? 1 : -1, 0);
  } else {
    setDir(0, dy > 0 ? 1 : -1);
  }
  touchStart = null;
}, { passive:false });

canvas.addEventListener("touchend", () => { touchStart = null; });

btnRestart.addEventListener("click", resetGame);
btnRestartTop?.addEventListener("click", resetGame);
btnBack?.addEventListener("click", () => { window.location.href = "panel.html"; });

/* ---------------------------------------------------------
 *  TICK (LOGIC)
 * --------------------------------------------------------- */
function gameOver(){
  state.playing = false;
  state.shake = 18;
  btnRestart.style.display = "inline-block";
  if(btnRestartTop) btnRestartTop.style.display = "inline-flex";
  playFx("hit");
  playFx("lose");
}

function tick(){
  if(!state.playing) return;

  dir = nextDir;

  const head = snake[0];
  const nh = { x: head.x + dir.x, y: head.y + dir.y };

  // walls bounds
  if(nh.x < 0 || nh.y < 0 || nh.x >= GRID || nh.y >= GRID){
    gameOver();
    return;
  }

  // obstacle collision
  if(isWallCell(nh.x, nh.y)){
    gameOver();
    return;
  }

  // self collision
  if(snake.some((s, idx) => idx > 0 && s.x === nh.x && s.y === nh.y)){
    gameOver();
    return;
  }

  snake.unshift(nh);

  // eat coin
  if(nh.x === coin.x && nh.y === coin.y){
    state.coins++;
    state.score += SCORE_PER_COIN;
    hudCoins.textContent = String(state.coins);
    hudScore.textContent = String(state.score);
    playFx("coin");

    // Partículas doradas
    const px = boardX + coin.x*TILE + TILE/2;
    const py = boardY + coin.y*TILE + TILE/2;
    emitParticles(px, py, 22, {
      color: "#fde047",
      minVx: -2.6, maxVx: 2.6,
      minVy: -3.4, maxVy: -1.0,
      life: 34,
      gravity: 0.09,
      glow: true
    });

    placeCoin();

    const newLevel = Math.floor(state.score / LEVEL_EVERY_POINTS) + 1;
    if(newLevel > state.level){
      state.level = newLevel;
      hudLevel.textContent = String(state.level);
      state.banner = BANNER_FRAMES;

      playFx("levelup");

      // “Swoosh” visual
      state.swoosh = 28;
      state.swooshFlash = 12;
      state.shake = Math.max(state.shake, 14);

      // Partículas neón por nivel
      const hx = boardX + snake[0].x*TILE + TILE/2;
      const hy = boardY + snake[0].y*TILE + TILE/2;
      emitParticles(hx, hy, 26, {
        color: "#38bdf8",
        minVx: -3.2, maxVx: 3.2,
        minVy: -3.6, maxVy: -1.2,
        life: 40,
        gravity: 0.10,
        glow: true
      });

      // aumenta obstáculos y recalcula paredes (sin destruir la partida)
      rebuildWallsForLevel();
      // asegura que la moneda no quede sobre muro
      placeCoin();

      // acelera el step
      state.stepMs = clamp(state.stepMs - 10, MIN_STEP_MS, BASE_STEP_MS);
      clearInterval(tickTimer);
      tickTimer = setInterval(tick, state.stepMs);
    }
  } else {
    snake.pop();
  }
}

/* ---------------------------------------------------------
 *  DRAW HELPERS (3D LOOK)
 * --------------------------------------------------------- */
function applyShake(){
  if(state.shake <= 0) return {x:0,y:0};
  const power = state.shake / 18;
  return {
    x: (Math.random()-0.5) * 10 * power,
    y: (Math.random()-0.5) * 6 * power
  };
}

function drawBoardBackground(){
  const g = ctx.createLinearGradient(0, 0, 0, H);
  g.addColorStop(0, "#0b1224");
  g.addColorStop(1, "#020617");
  ctx.fillStyle = g;
  ctx.fillRect(0, 0, W, H);

  // outer board (depth)
  ctx.save();
  ctx.shadowColor = "rgba(0,0,0,0.45)";
  ctx.shadowBlur = 18;
  ctx.shadowOffsetY = 8;
  ctx.fillStyle = "rgba(15,23,42,0.78)";
  roundedRectPath(ctx, boardX-10, boardY-10, BOARD_W+20, BOARD_H+20, 18);
  ctx.fill();
  ctx.restore();

  // inner board
  const b = ctx.createLinearGradient(boardX, boardY, boardX, boardY + BOARD_H);
  b.addColorStop(0, "rgba(30,58,138,0.20)");
  b.addColorStop(1, "rgba(2,6,23,0.28)");
  ctx.fillStyle = b;
  roundedRectPath(ctx, boardX, boardY, BOARD_W, BOARD_H, 14);
  ctx.fill();

  // subtle grid
  ctx.save();
  ctx.globalAlpha = 0.12;
  ctx.strokeStyle = "#93c5fd";
  ctx.lineWidth = 1;
  for(let i=1;i<GRID;i++){
    const x = boardX + i*TILE;
    const y = boardY + i*TILE;
    ctx.beginPath(); ctx.moveTo(x, boardY); ctx.lineTo(x, boardY + BOARD_H); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(boardX, y); ctx.lineTo(boardX + BOARD_W, y); ctx.stroke();
  }
  ctx.restore();

  // vignette
  const v = ctx.createRadialGradient(W*0.5, H*0.5, 80, W*0.5, H*0.5, 560);
  v.addColorStop(0, "rgba(255,255,255,0.05)");
  v.addColorStop(1, "rgba(0,0,0,0.35)");
  ctx.fillStyle = v;
  ctx.fillRect(0,0,W,H);
}

function drawWalls3D(){
  for(const w of walls){
    const x = boardX + w.x*TILE + 2;
    const y = boardY + w.y*TILE + 2;
    const s = TILE - 4;

    // shadow
    ctx.save();
    ctx.globalAlpha = 0.28;
    ctx.fillStyle = "#000";
    ctx.beginPath();
    ctx.ellipse(x + s*0.55, y + s*0.62 + 6, s*0.45, s*0.18, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    // body
    const g = ctx.createLinearGradient(x, y, x, y + s);
    g.addColorStop(0, "#334155");
    g.addColorStop(1, "#0f172a");

    roundedRectPath(ctx, x, y, s, s, 9);
    ctx.fillStyle = g;
    ctx.fill();

    // top shine
    ctx.globalAlpha = 0.75;
    const hl = ctx.createLinearGradient(x, y, x + s, y);
    hl.addColorStop(0, "rgba(255,255,255,0.22)");
    hl.addColorStop(0.6, "rgba(255,255,255,0.06)");
    hl.addColorStop(1, "rgba(255,255,255,0.00)");
    ctx.fillStyle = hl;
    roundedRectPath(ctx, x+2, y+2, s-4, Math.max(6, s*0.32), 8);
    ctx.fill();
    ctx.globalAlpha = 1;

    // edge
    ctx.strokeStyle = "rgba(56,189,248,0.22)";
    ctx.lineWidth = 1.2;
    roundedRectPath(ctx, x+0.6, y+0.6, s-1.2, s-1.2, 9);
    ctx.stroke();
  }
}

function drawCoinLikeRunner(){
  coin.spin += 0.09;
  const cx = boardX + coin.x*TILE + TILE/2;
  const cy = boardY + coin.y*TILE + TILE/2;

  const scale = 0.68 + 0.32 * Math.abs(Math.sin(coin.spin));
  const rx = coin.r * scale;
  const ry = coin.r;

  ctx.save();
  ctx.translate(cx, cy);

  ctx.globalAlpha = 0.28 + coin.glow * 0.25;
  ctx.beginPath();
  ctx.ellipse(0, 0, rx + 8, ry + 8, 0, 0, Math.PI * 2);
  ctx.fillStyle = "#fde047";
  ctx.fill();
  ctx.globalAlpha = 1;

  const grad = ctx.createRadialGradient(-4, -4, 2, 0, 0, ry + 6);
  grad.addColorStop(0, "#fff7c2");
  grad.addColorStop(0.45, "#fde047");
  grad.addColorStop(1, "#a16207");

  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.ellipse(0, 0, rx, ry, 0, 0, Math.PI * 2);
  ctx.fill();

  ctx.strokeStyle = "rgba(0,0,0,0.22)";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.ellipse(0, 0, rx - 2.6, ry - 2.6, 0, 0, Math.PI * 2);
  ctx.stroke();

  ctx.fillStyle = "#78350f";
  ctx.font = "12px Lato";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("★", 0, 1);

  ctx.restore();
}

function drawSnake3D(){
  // Shadow under snake
  ctx.save();
  ctx.globalAlpha = 0.18;
  ctx.fillStyle = "#000";
  for(const s of snake){
    const x = boardX + s.x*TILE;
    const y = boardY + s.y*TILE;
    ctx.beginPath();
    ctx.ellipse(x + TILE/2, y + TILE/2 + 6, TILE*0.42, TILE*0.22, 0, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.restore();

  // Segments
  for(let i = snake.length-1; i >= 0; i--){
    const s = snake[i];
    const x = boardX + s.x*TILE + 2;
    const y = boardY + s.y*TILE + 2;
    const w = TILE - 4;
    const h = TILE - 4;

    const body = ctx.createLinearGradient(x, y, x, y + h);
    body.addColorStop(0, i === 0 ? "#4ade80" : "#34d399");
    body.addColorStop(1, i === 0 ? "#15803d" : "#166534");

    roundedRectPath(ctx, x, y, w, h, 10);
    ctx.fillStyle = body;
    ctx.fill();

    const hl = ctx.createLinearGradient(x, y, x + w, y);
    hl.addColorStop(0, "rgba(255,255,255,0.22)");
    hl.addColorStop(0.55, "rgba(255,255,255,0.06)");
    hl.addColorStop(1, "rgba(255,255,255,0.00)");
    ctx.fillStyle = hl;
    roundedRectPath(ctx, x + 2, y + 2, w - 4, h - 4, 9);
    ctx.fill();

    ctx.strokeStyle = "rgba(15,23,42,0.45)";
    ctx.lineWidth = 1.1;
    roundedRectPath(ctx, x + 0.6, y + 0.6, w - 1.2, h - 1.2, 10);
    ctx.stroke();

    if(i === 0){
      // Head details
      const hx = x, hy = y, hw = w, hh = h;

      ctx.fillStyle = "rgba(236,254,255,0.95)";
      ctx.beginPath();
      ctx.arc(hx + hw*0.35, hy + hh*0.40, 3.2, 0, Math.PI*2);
      ctx.arc(hx + hw*0.65, hy + hh*0.40, 3.2, 0, Math.PI*2);
      ctx.fill();

      ctx.fillStyle = "#0b1224";
      ctx.beginPath();
      ctx.arc(hx + hw*0.35, hy + hh*0.40, 1.6, 0, Math.PI*2);
      ctx.arc(hx + hw*0.65, hy + hh*0.40, 1.6, 0, Math.PI*2);
      ctx.fill();

      ctx.globalAlpha = 0.35;
      ctx.fillStyle = "#ffffff";
      ctx.beginPath();
      ctx.ellipse(hx + hw*0.70, hy + hh*0.25, 5.5, 3.0, -0.2, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
  }
}

function drawLevelBanner(){
  if(state.banner <= 0) return;

  const alpha = Math.min(1, state.banner / 40);
  const bw = 300, bh = 66;
  const bx = (W - bw) / 2;
  const by = 34;

  ctx.save();
  ctx.globalAlpha = alpha;

  ctx.fillStyle = "rgba(15,23,42,0.90)";
  roundedRectPath(ctx, bx, by, bw, bh, 14);
  ctx.fill();

  ctx.shadowColor = "rgba(56,189,248,0.55)";
  ctx.shadowBlur = 12;
  ctx.strokeStyle = "#38bdf8";
  ctx.lineWidth = 2;
  roundedRectPath(ctx, bx + 0.5, by + 0.5, bw - 1, bh - 1, 14);
  ctx.stroke();
  ctx.shadowBlur = 0;

  ctx.fillStyle = "#f9fafb";
  ctx.font = "800 22px Lato";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("Nivel " + state.level, W/2, by + bh/2);

  ctx.restore();
}

function drawSwoosh(){
  if(state.swoosh <= 0 && state.swooshFlash <= 0) return;

  // flash
  if(state.swooshFlash > 0){
    const a = state.swooshFlash / 12;
    ctx.globalAlpha = 0.18 * a;
    ctx.fillStyle = "#38bdf8";
    ctx.fillRect(0,0,W,H);
    ctx.globalAlpha = 1;
  }

  // speed lines
  if(state.swoosh > 0){
    const a = state.swoosh / 28;
    ctx.save();
    ctx.globalAlpha = 0.24 * a;
    ctx.strokeStyle = "#93c5fd";
    ctx.lineWidth = 2;

    for(let i=0;i<18;i++){
      const y = 40 + i * 26;
      const x1 = rand(40, W*0.25);
      const x2 = rand(W*0.70, W-40);
      ctx.beginPath();
      ctx.moveTo(x1, y + rand(-6,6));
      ctx.lineTo(x2, y + rand(-6,6));
      ctx.stroke();
    }
    ctx.restore();
  }
}

function drawGameOver(){
  ctx.fillStyle = "rgba(10, 15, 30, 0.76)";
  ctx.fillRect(0, 0, W, H);

  const bw = 560, bh = 170;
  const bx = (W - bw) / 2;
  const by = (H - bh) / 2 - 8;

  ctx.save();
  ctx.shadowColor = "rgba(56,189,248,0.35)";
  ctx.shadowBlur = 22;

  ctx.fillStyle = "rgba(15,23,42,0.90)";
  roundedRectPath(ctx, bx, by, bw, bh, 18);
  ctx.fill();

  ctx.shadowBlur = 0;
  ctx.strokeStyle = "rgba(56,189,248,0.75)";
  ctx.lineWidth = 2;
  roundedRectPath(ctx, bx + 0.5, by + 0.5, bw - 1, bh - 1, 18);
  ctx.stroke();

  ctx.fillStyle = "#f9fafb";
  ctx.font = "900 30px Lato";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("Juego terminado", W / 2, by + 54);

  ctx.font = "700 16px Lato";
  ctx.fillText(`Puntaje: ${state.score}  |  Nivel: ${state.level}  |  Monedas: ${state.coins}`, W / 2, by + 96);

  ctx.font = "600 13px Lato";
  ctx.fillStyle = "rgba(249,250,251,0.85)";
  ctx.fillText(`Pulsa "Reintentar" (o Enter / R) para jugar de nuevo.`, W / 2, by + 128);

  ctx.restore();
}

/* ---------------------------------------------------------
 *  MAIN DRAW LOOP (RAF)
 * --------------------------------------------------------- */
function update(){
  state.frame++;
  if(state.shake > 0) state.shake--;
  if(state.banner > 0) state.banner--;
  if(state.swoosh > 0) state.swoosh--;
  if(state.swooshFlash > 0) state.swooshFlash--;

  updateParticles();
}

function draw(){
  const shake = applyShake();

  ctx.save();
  ctx.clearRect(0,0,W,H);
  ctx.translate(shake.x, shake.y);

  drawBoardBackground();
  drawWalls3D();          // NUEVO: paredes 3D
  drawCoinLikeRunner();   // moneda igual al runner
  drawParticles();        // NUEVO: partículas
  drawSnake3D();          // snake 3D
  drawLevelBanner();      // banner nivel
  drawSwoosh();           // NUEVO: swoosh al subir nivel

  if(!state.playing) drawGameOver();

  ctx.restore();
}

function raf(){
  update();
  draw();
  requestAnimationFrame(raf);
}

/* ---------------------------------------------------------
 *  START
 * --------------------------------------------------------- */
handleResize();
resetGame();
raf();

})();

  </script>
</body>
</html>
