<!doctype html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Culebra C√≥smica</title>

<style>
  :root{
    --bg1:#4a90e2;
    --bg2:#1a3c6e;
    --panel:#0f172af5;
    --muted:#cbd5f5;
    --text:#f9fafb;
    --accent:#38bdf8;
    --gold:#facc15;
  }

  *{ box-sizing:border-box; margin:0; padding:0; font-family:"Lato", system-ui, -apple-system, BlinkMacSystemFont, sans-serif; }

  body{
    min-height:100vh;
    display:flex;
    align-items:center;
    justify-content:center;
    background:linear-gradient(var(--bg1), var(--bg2));
    color:var(--text);
    padding:16px;
  }

  .game-wrapper{
    width:100%;
    max-width:860px;
    background:var(--panel);
    border-radius:24px;
    box-shadow:0 14px 28px rgba(0,0,0,.35);
    padding:18px 18px 22px;
    display:flex;
    flex-direction:column;
    gap:12px;
    position:relative;
    overflow:hidden;
  }

  .game-header{
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:12px;
  }

  .game-header-left h1{
    font-size:18px;
    font-weight:800;
    letter-spacing:.2px;
  }

  .game-header-left p{
    font-size:13px;
    color:var(--muted);
    line-height:1.25;
    max-width:520px;
  }

  .game-header-right{
    display:flex;
    flex-direction:column;
    align-items:flex-end;
    gap:6px;
  }

  .btn-volver{
    border:none;
    border-radius:14px;
    padding:7px 12px;
    font-size:13px;
    font-weight:800;
    cursor:pointer;
    background:#e2e8f0;
    color:#0f172a;
    box-shadow:0 3px 0 #cbd5e1;
    transition:transform .12s ease, box-shadow .12s ease;
    user-select:none;
  }
  .btn-volver:hover{ transform:translateY(-1px); box-shadow:0 5px 0 #cbd5e1; }
  .btn-volver:active{ transform:translateY(2px); box-shadow:0 1px 0 #cbd5e1; }

  .hud{
    display:flex;
    gap:12px;
    font-size:13px;
    color:#e5e7eb;
    flex-wrap:wrap;
    justify-content:flex-end;
  }
  .hud span strong{ color:var(--gold); }

  .game-container{
    margin-top:6px;
    background:linear-gradient(#1d4ed8, #1e293b);
    border-radius:20px;
    padding:10px 10px 12px;
    box-shadow:inset 0 0 0 1px rgba(15,23,42,.4);
  }

  canvas{
    display:block;
    width:100%;
    max-width:860px;
    height:auto;
    border-radius:16px;
    background:#0b1224;
  }

  .help{
    font-size:12px;
    color:var(--muted);
    margin-top:6px;
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:8px;
    flex-wrap:wrap;
  }

  .btn-restart{
    border:none;
    border-radius:14px;
    padding:7px 14px;
    font-size:12px;
    font-weight:900;
    cursor:pointer;
    background:linear-gradient(135deg,#22c55e,#16a34a);
    color:var(--text);
    box-shadow:0 3px 0 #15803d;
    display:none;
    transition:transform .12s ease, box-shadow .12s ease, filter .12s ease;
    user-select:none;
  }
  .btn-restart:hover{ transform:translateY(-1px); box-shadow:0 5px 0 #15803d; filter:brightness(1.03); }
  .btn-restart:active{ transform:translateY(2px); box-shadow:0 1px 0 #15803d; }
</style>
</head>

<body>
  <div class="game-wrapper">
    <div class="game-header">
      <div class="game-header-left">
        <h1>Culebra C√≥smica</h1>
        <p>Come monedas, evita chocar y sube de nivel. M√°s nivel = m√°s velocidad y m√°s obst√°culos.</p>
      </div>

      <div class="game-header-right">
        <button class="btn-volver" onclick="window.location.href='panel.html'">‚¨Ö Volver al panel</button>
        <div class="hud">
          <span>Puntaje: <strong id="hudScore">0</strong></span>
          <span>| Nivel: <strong id="hudLevel">1</strong></span>
          <span>| Monedas: <strong id="hudCoins">0</strong></span>
        </div>
      </div>
    </div>

    <div class="game-container">
      <canvas id="gameCanvas" width="840" height="520"></canvas>
      <div class="help">
        <span>Controles: ‚Üê ‚Üë ‚Üí ‚Üì (m√≥vil: desliza). Enter / R para reintentar.</span>
        <button id="btnRestart" class="btn-restart">üîÑ Reintentar</button>
      </div>
    </div>
  </div>

<script>
(() => {
"use strict";

/* ---------------------------------------------------------
 *  DOM / CANVAS
 * --------------------------------------------------------- */
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d", { alpha:true });

const hudScore = document.getElementById("hudScore");
const hudLevel = document.getElementById("hudLevel");
const hudCoins = document.getElementById("hudCoins");
const btnRestart = document.getElementById("btnRestart");

const W = canvas.width;
const H = canvas.height;

/* ---------------------------------------------------------
 *  CONFIG
 * --------------------------------------------------------- */
const GRID = 24;
const TILE = Math.floor(Math.min(W, H) / GRID);
const BOARD_W = TILE * GRID;
const BOARD_H = TILE * GRID;

const boardX = Math.floor((W - BOARD_W) / 2);
const boardY = Math.floor((H - BOARD_H) / 2);

const SCORE_PER_COIN = 10;
const LEVEL_EVERY_POINTS = 50;

const BASE_STEP_MS = 135;
const MIN_STEP_MS = 65;

const BANNER_FRAMES = 110;

// Obst√°culos (crecen por nivel)
const OBST_BASE = 8;          // cantidad base de ‚Äúceldas pared‚Äù
const OBST_PER_LEVEL = 3;     // celdas adicionales por nivel
const OBST_MAX = 60;          // l√≠mite para no saturar

/* ---------------------------------------------------------
 *  UTILS
 * --------------------------------------------------------- */
const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
const rand = (a, b) => a + Math.random() * (b - a);

function roundedRectPath(g, x, y, w, h, r){
  const rr = Math.min(r, w/2, h/2);
  g.beginPath();
  g.moveTo(x+rr, y);
  g.lineTo(x+w-rr, y);
  g.quadraticCurveTo(x+w, y, x+w, y+rr);
  g.lineTo(x+w, y+h-rr);
  g.quadraticCurveTo(x+w, y+h, x+w-rr, y+h);
  g.lineTo(x+rr, y+h);
  g.quadraticCurveTo(x, y+h, x, y+h-rr);
  g.lineTo(x, y+rr);
  g.quadraticCurveTo(x, y, x+rr, y);
  g.closePath();
}

/* ---------------------------------------------------------
 *  AUDIO (FX)
 * --------------------------------------------------------- */
let fxCtx = null;
function getFxCtx(){
  if(!fxCtx){
    const AC = window.AudioContext || window.webkitAudioContext;
    if(AC) fxCtx = new AC();
  }
  return fxCtx;
}

function fxBeep(steps, dur = 0.28, vol = 0.18, type = "square"){
  const ac = getFxCtx();
  if(!ac) return;
  if(ac.state === "suspended") ac.resume();

  const now = ac.currentTime;
  const osc = ac.createOscillator();
  const gain = ac.createGain();

  osc.type = type;
  gain.gain.setValueAtTime(vol, now);

  osc.connect(gain);
  gain.connect(ac.destination);

  for(const s of steps){
    osc.frequency.setValueAtTime(s.freq, now + s.time);
  }

  gain.gain.exponentialRampToValueAtTime(0.001, now + dur);
  osc.start(now);
  osc.stop(now + dur + 0.02);
}

function playFx(kind){
  switch(kind){
    case "coin":
      fxBeep([{time:0.00,freq:900},{time:0.05,freq:1100},{time:0.10,freq:1350}], 0.22, 0.20);
      break;
    case "levelup":
      fxBeep([{time:0.00,freq:600},{time:0.06,freq:800},{time:0.12,freq:1000}], 0.28, 0.18);
      break;
    case "hit":
      fxBeep([{time:0.00,freq:400},{time:0.05,freq:260},{time:0.10,freq:180}], 0.26, 0.20);
      break;
    case "lose": {
      const ac = getFxCtx();
      if(!ac) return;
      if(ac.state === "suspended") ac.resume();

      const now = ac.currentTime;
      const osc = ac.createOscillator();
      const gain = ac.createGain();
      const filter = ac.createBiquadFilter();

      osc.type = "square";
      filter.type = "lowpass";
      filter.frequency.setValueAtTime(1800, now);
      filter.frequency.exponentialRampToValueAtTime(250, now + 0.75);

      gain.gain.setValueAtTime(0.22, now);
      gain.gain.exponentialRampToValueAtTime(0.001, now + 0.85);

      osc.connect(filter);
      filter.connect(gain);
      gain.connect(ac.destination);

      osc.frequency.setValueAtTime(520, now);
      osc.frequency.exponentialRampToValueAtTime(110, now + 0.85);

      osc.start(now);
      osc.stop(now + 0.9);
      break;
    }
    default:
      fxBeep([{time:0.00,freq:500},{time:0.07,freq:650}], 0.22, 0.14);
  }
}

/* ---------------------------------------------------------
 *  STATE
 * --------------------------------------------------------- */
const state = {
  frame: 0,
  score: 0,
  coins: 0,
  level: 1,
  playing: true,
  banner: 0,
  shake: 0,
  stepMs: BASE_STEP_MS,

  // ‚ÄúSwoosh‚Äù visual cuando sube nivel
  swoosh: 0,     // frames
  swooshFlash: 0 // frames
};

let snake = [];
let dir = { x: 1, y: 0 };
let nextDir = { x: 1, y: 0 };

const coin = {
  x: 0, y: 0,
  r: 11,
  spin: rand(0, Math.PI * 2),
  glow: rand(0.35, 0.85)
};

const walls = [];        // celdas bloqueadas: {x,y}
const particles = [];    // part√≠culas: {x,y,vx,vy,r,life,t,color,glow}

let tickTimer = null;

// Touch swipe
let touchStart = null;

/* ---------------------------------------------------------
 *  PARTICLES
 * --------------------------------------------------------- */
function emitParticles(px, py, count, cfg = {}){
  const {
    minVx = -2.2, maxVx = 2.2,
    minVy = -2.8, maxVy = -0.8,
    minR  = 1.2,  maxR  = 3.0,
    life  = 34,
    gravity = 0.10,
    drag = 0.985,
    color = "#fde047",
    glow = true
  } = cfg;

  for(let i=0;i<count;i++){
    particles.push({
      x: px, y: py,
      vx: rand(minVx, maxVx),
      vy: rand(minVy, maxVy),
      r: rand(minR, maxR),
      life: life + Math.floor(rand(-8, 10)),
      t: 0,
      g: gravity,
      d: drag,
      color,
      glow
    });
  }
}

function updateParticles(){
  for(let i = particles.length-1; i >= 0; i--){
    const p = particles[i];
    p.t++;
    p.vx *= p.d;
    p.vy = (p.vy + p.g) * p.d;
    p.x += p.vx;
    p.y += p.vy;
    if(p.t >= p.life) particles.splice(i, 1);
  }
}

function drawParticles(){
  for(const p of particles){
    const a = 1 - (p.t / p.life);
    ctx.globalAlpha = a;

    if(p.glow){
      ctx.shadowColor = p.color;
      ctx.shadowBlur = 10 * a;
    } else {
      ctx.shadowBlur = 0;
    }

    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
    ctx.fill();

    ctx.shadowBlur = 0;
  }
  ctx.globalAlpha = 1;
}

/* ---------------------------------------------------------
 *  WALLS / OBSTACLES
 * --------------------------------------------------------- */
function wallKey(x,y){ return x + ":" + y; }

function isWallCell(x,y){
  return walls.some(w => w.x===x && w.y===y);
}

function rebuildWallsForLevel(){
  walls.length = 0;

  // cantidad de celdas de pared seg√∫n nivel
  const target = clamp(OBST_BASE + (state.level-1)*OBST_PER_LEVEL, 0, OBST_MAX);

  const start = snake[0];
  const forbidden = new Set();

  // zona de seguridad alrededor de la cabeza
  for(let dy=-2; dy<=2; dy++){
    for(let dx=-2; dx<=2; dx++){
      const ax = start.x + dx;
      const ay = start.y + dy;
      if(ax>=0 && ay>=0 && ax<GRID && ay<GRID) forbidden.add(wallKey(ax,ay));
    }
  }

  // y alrededor de la cola inicial para no encerrar al inicio
  for(const s of snake){
    forbidden.add(wallKey(s.x,s.y));
  }

  const used = new Set([...forbidden]);

  let tries = 0;
  while(walls.length < target && tries < 2500){
    tries++;

    // preferimos ‚Äúbloques‚Äù que se sientan como muros: prob de 70% de extender desde un muro existente
    let x, y;
    if(walls.length > 0 && Math.random() < 0.7){
      const base = walls[Math.floor(Math.random()*walls.length)];
      const dirs = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];
      const d = dirs[Math.floor(Math.random()*dirs.length)];
      x = base.x + d.x;
      y = base.y + d.y;
    } else {
      x = Math.floor(Math.random()*GRID);
      y = Math.floor(Math.random()*GRID);
    }

    if(x<0 || y<0 || x>=GRID || y>=GRID) continue;

    const k = wallKey(x,y);
    if(used.has(k)) continue;

    // evitamos bordes muy cargados para que sea jugable
    if((x===0 || y===0 || x===GRID-1 || y===GRID-1) && Math.random() < 0.55) continue;

    walls.push({x,y});
    used.add(k);
  }
}

/* ---------------------------------------------------------
 *  GAME INIT / RESET
 * --------------------------------------------------------- */
function placeCoin(){
  while(true){
    const cx = Math.floor(Math.random() * GRID);
    const cy = Math.floor(Math.random() * GRID);

    if(snake.some(s => s.x === cx && s.y === cy)) continue;
    if(isWallCell(cx,cy)) continue;

    coin.x = cx;
    coin.y = cy;
    coin.spin = rand(0, Math.PI * 2);
    coin.glow = rand(0.35, 0.85);
    return;
  }
}

function resetGame(){
  state.frame = 0;
  state.score = 0;
  state.coins = 0;
  state.level = 1;
  state.playing = true;
  state.banner = 0;
  state.shake = 0;
  state.stepMs = BASE_STEP_MS;
  state.swoosh = 0;
  state.swooshFlash = 0;

  particles.length = 0;

  snake = [
    {x: Math.floor(GRID*0.5), y: Math.floor(GRID*0.5)},
    {x: Math.floor(GRID*0.5)-1, y: Math.floor(GRID*0.5)},
    {x: Math.floor(GRID*0.5)-2, y: Math.floor(GRID*0.5)}
  ];

  dir = {x:1,y:0};
  nextDir = {x:1,y:0};

  rebuildWallsForLevel();
  placeCoin();

  hudScore.textContent = "0";
  hudLevel.textContent = "1";
  hudCoins.textContent = "0";

  btnRestart.style.display = "none";

  if(tickTimer) clearInterval(tickTimer);
  tickTimer = setInterval(tick, state.stepMs);
}

/* ---------------------------------------------------------
 *  INPUT
 * --------------------------------------------------------- */
function setDir(nx, ny){
  if(nx === -dir.x && ny === -dir.y) return;
  nextDir = { x:nx, y:ny };
}

document.addEventListener("keydown", (e) => {
  if(e.code === "ArrowUp") { e.preventDefault(); setDir(0,-1); }
  if(e.code === "ArrowDown") { e.preventDefault(); setDir(0,1); }
  if(e.code === "ArrowLeft") { e.preventDefault(); setDir(-1,0); }
  if(e.code === "ArrowRight") { e.preventDefault(); setDir(1,0); }

  if(!state.playing && (e.code === "Enter" || e.code === "KeyR")) resetGame();
});

canvas.addEventListener("touchstart", (e) => {
  e.preventDefault();
  const t = e.touches[0];
  touchStart = { x: t.clientX, y: t.clientY };
}, { passive:false });

canvas.addEventListener("touchmove", (e) => {
  e.preventDefault();
  if(!touchStart) return;
  const t = e.touches[0];
  const dx = t.clientX - touchStart.x;
  const dy = t.clientY - touchStart.y;

  if(Math.abs(dx) < 18 && Math.abs(dy) < 18) return;

  if(Math.abs(dx) > Math.abs(dy)){
    setDir(dx > 0 ? 1 : -1, 0);
  } else {
    setDir(0, dy > 0 ? 1 : -1);
  }
  touchStart = null;
}, { passive:false });

canvas.addEventListener("touchend", () => { touchStart = null; });

btnRestart.addEventListener("click", resetGame);

/* ---------------------------------------------------------
 *  TICK (LOGIC)
 * --------------------------------------------------------- */
function gameOver(){
  state.playing = false;
  state.shake = 18;
  btnRestart.style.display = "inline-block";
  playFx("hit");
  playFx("lose");
}

function tick(){
  if(!state.playing) return;

  dir = nextDir;

  const head = snake[0];
  const nh = { x: head.x + dir.x, y: head.y + dir.y };

  // walls bounds
  if(nh.x < 0 || nh.y < 0 || nh.x >= GRID || nh.y >= GRID){
    gameOver();
    return;
  }

  // obstacle collision
  if(isWallCell(nh.x, nh.y)){
    gameOver();
    return;
  }

  // self collision
  if(snake.some((s, idx) => idx > 0 && s.x === nh.x && s.y === nh.y)){
    gameOver();
    return;
  }

  snake.unshift(nh);

  // eat coin
  if(nh.x === coin.x && nh.y === coin.y){
    state.coins++;
    state.score += SCORE_PER_COIN;
    hudCoins.textContent = String(state.coins);
    hudScore.textContent = String(state.score);
    playFx("coin");

    // Part√≠culas doradas
    const px = boardX + coin.x*TILE + TILE/2;
    const py = boardY + coin.y*TILE + TILE/2;
    emitParticles(px, py, 22, {
      color: "#fde047",
      minVx: -2.6, maxVx: 2.6,
      minVy: -3.4, maxVy: -1.0,
      life: 34,
      gravity: 0.09,
      glow: true
    });

    placeCoin();

    const newLevel = Math.floor(state.score / LEVEL_EVERY_POINTS) + 1;
    if(newLevel > state.level){
      state.level = newLevel;
      hudLevel.textContent = String(state.level);
      state.banner = BANNER_FRAMES;

      playFx("levelup");

      // ‚ÄúSwoosh‚Äù visual
      state.swoosh = 28;
      state.swooshFlash = 12;
      state.shake = Math.max(state.shake, 14);

      // Part√≠culas ne√≥n por nivel
      const hx = boardX + snake[0].x*TILE + TILE/2;
      const hy = boardY + snake[0].y*TILE + TILE/2;
      emitParticles(hx, hy, 26, {
        color: "#38bdf8",
        minVx: -3.2, maxVx: 3.2,
        minVy: -3.6, maxVy: -1.2,
        life: 40,
        gravity: 0.10,
        glow: true
      });

      // aumenta obst√°culos y recalcula paredes (sin destruir la partida)
      rebuildWallsForLevel();
      // asegura que la moneda no quede sobre muro
      placeCoin();

      // acelera el step
      state.stepMs = clamp(state.stepMs - 10, MIN_STEP_MS, BASE_STEP_MS);
      clearInterval(tickTimer);
      tickTimer = setInterval(tick, state.stepMs);
    }
  } else {
    snake.pop();
  }
}

/* ---------------------------------------------------------
 *  DRAW HELPERS (3D LOOK)
 * --------------------------------------------------------- */
function applyShake(){
  if(state.shake <= 0) return {x:0,y:0};
  const power = state.shake / 18;
  return {
    x: (Math.random()-0.5) * 10 * power,
    y: (Math.random()-0.5) * 6 * power
  };
}

function drawBoardBackground(){
  const g = ctx.createLinearGradient(0, 0, 0, H);
  g.addColorStop(0, "#0b1224");
  g.addColorStop(1, "#020617");
  ctx.fillStyle = g;
  ctx.fillRect(0, 0, W, H);

  // outer board (depth)
  ctx.save();
  ctx.shadowColor = "rgba(0,0,0,0.45)";
  ctx.shadowBlur = 18;
  ctx.shadowOffsetY = 8;
  ctx.fillStyle = "rgba(15,23,42,0.78)";
  roundedRectPath(ctx, boardX-10, boardY-10, BOARD_W+20, BOARD_H+20, 18);
  ctx.fill();
  ctx.restore();

  // inner board
  const b = ctx.createLinearGradient(boardX, boardY, boardX, boardY + BOARD_H);
  b.addColorStop(0, "rgba(30,58,138,0.20)");
  b.addColorStop(1, "rgba(2,6,23,0.28)");
  ctx.fillStyle = b;
  roundedRectPath(ctx, boardX, boardY, BOARD_W, BOARD_H, 14);
  ctx.fill();

  // subtle grid
  ctx.save();
  ctx.globalAlpha = 0.12;
  ctx.strokeStyle = "#93c5fd";
  ctx.lineWidth = 1;
  for(let i=1;i<GRID;i++){
    const x = boardX + i*TILE;
    const y = boardY + i*TILE;
    ctx.beginPath(); ctx.moveTo(x, boardY); ctx.lineTo(x, boardY + BOARD_H); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(boardX, y); ctx.lineTo(boardX + BOARD_W, y); ctx.stroke();
  }
  ctx.restore();

  // vignette
  const v = ctx.createRadialGradient(W*0.5, H*0.5, 80, W*0.5, H*0.5, 560);
  v.addColorStop(0, "rgba(255,255,255,0.05)");
  v.addColorStop(1, "rgba(0,0,0,0.35)");
  ctx.fillStyle = v;
  ctx.fillRect(0,0,W,H);
}

function drawWalls3D(){
  for(const w of walls){
    const x = boardX + w.x*TILE + 2;
    const y = boardY + w.y*TILE + 2;
    const s = TILE - 4;

    // shadow
    ctx.save();
    ctx.globalAlpha = 0.28;
    ctx.fillStyle = "#000";
    ctx.beginPath();
    ctx.ellipse(x + s*0.55, y + s*0.62 + 6, s*0.45, s*0.18, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.restore();

    // body
    const g = ctx.createLinearGradient(x, y, x, y + s);
    g.addColorStop(0, "#334155");
    g.addColorStop(1, "#0f172a");

    roundedRectPath(ctx, x, y, s, s, 9);
    ctx.fillStyle = g;
    ctx.fill();

    // top shine
    ctx.globalAlpha = 0.75;
    const hl = ctx.createLinearGradient(x, y, x + s, y);
    hl.addColorStop(0, "rgba(255,255,255,0.22)");
    hl.addColorStop(0.6, "rgba(255,255,255,0.06)");
    hl.addColorStop(1, "rgba(255,255,255,0.00)");
    ctx.fillStyle = hl;
    roundedRectPath(ctx, x+2, y+2, s-4, Math.max(6, s*0.32), 8);
    ctx.fill();
    ctx.globalAlpha = 1;

    // edge
    ctx.strokeStyle = "rgba(56,189,248,0.22)";
    ctx.lineWidth = 1.2;
    roundedRectPath(ctx, x+0.6, y+0.6, s-1.2, s-1.2, 9);
    ctx.stroke();
  }
}

function drawCoinLikeRunner(){
  coin.spin += 0.09;
  const cx = boardX + coin.x*TILE + TILE/2;
  const cy = boardY + coin.y*TILE + TILE/2;

  const scale = 0.68 + 0.32 * Math.abs(Math.sin(coin.spin));
  const rx = coin.r * scale;
  const ry = coin.r;

  ctx.save();
  ctx.translate(cx, cy);

  ctx.globalAlpha = 0.28 + coin.glow * 0.25;
  ctx.beginPath();
  ctx.ellipse(0, 0, rx + 8, ry + 8, 0, 0, Math.PI * 2);
  ctx.fillStyle = "#fde047";
  ctx.fill();
  ctx.globalAlpha = 1;

  const grad = ctx.createRadialGradient(-4, -4, 2, 0, 0, ry + 6);
  grad.addColorStop(0, "#fff7c2");
  grad.addColorStop(0.45, "#fde047");
  grad.addColorStop(1, "#a16207");

  ctx.fillStyle = grad;
  ctx.beginPath();
  ctx.ellipse(0, 0, rx, ry, 0, 0, Math.PI * 2);
  ctx.fill();

  ctx.strokeStyle = "rgba(0,0,0,0.22)";
  ctx.lineWidth = 1;
  ctx.beginPath();
  ctx.ellipse(0, 0, rx - 2.6, ry - 2.6, 0, 0, Math.PI * 2);
  ctx.stroke();

  ctx.fillStyle = "#78350f";
  ctx.font = "12px Lato";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("‚òÖ", 0, 1);

  ctx.restore();
}

function drawSnake3D(){
  // Shadow under snake
  ctx.save();
  ctx.globalAlpha = 0.18;
  ctx.fillStyle = "#000";
  for(const s of snake){
    const x = boardX + s.x*TILE;
    const y = boardY + s.y*TILE;
    ctx.beginPath();
    ctx.ellipse(x + TILE/2, y + TILE/2 + 6, TILE*0.42, TILE*0.22, 0, 0, Math.PI*2);
    ctx.fill();
  }
  ctx.restore();

  // Segments
  for(let i = snake.length-1; i >= 0; i--){
    const s = snake[i];
    const x = boardX + s.x*TILE + 2;
    const y = boardY + s.y*TILE + 2;
    const w = TILE - 4;
    const h = TILE - 4;

    const body = ctx.createLinearGradient(x, y, x, y + h);
    body.addColorStop(0, i === 0 ? "#4ade80" : "#34d399");
    body.addColorStop(1, i === 0 ? "#15803d" : "#166534");

    roundedRectPath(ctx, x, y, w, h, 10);
    ctx.fillStyle = body;
    ctx.fill();

    const hl = ctx.createLinearGradient(x, y, x + w, y);
    hl.addColorStop(0, "rgba(255,255,255,0.22)");
    hl.addColorStop(0.55, "rgba(255,255,255,0.06)");
    hl.addColorStop(1, "rgba(255,255,255,0.00)");
    ctx.fillStyle = hl;
    roundedRectPath(ctx, x + 2, y + 2, w - 4, h - 4, 9);
    ctx.fill();

    ctx.strokeStyle = "rgba(15,23,42,0.45)";
    ctx.lineWidth = 1.1;
    roundedRectPath(ctx, x + 0.6, y + 0.6, w - 1.2, h - 1.2, 10);
    ctx.stroke();

    if(i === 0){
      // Head details
      const hx = x, hy = y, hw = w, hh = h;

      ctx.fillStyle = "rgba(236,254,255,0.95)";
      ctx.beginPath();
      ctx.arc(hx + hw*0.35, hy + hh*0.40, 3.2, 0, Math.PI*2);
      ctx.arc(hx + hw*0.65, hy + hh*0.40, 3.2, 0, Math.PI*2);
      ctx.fill();

      ctx.fillStyle = "#0b1224";
      ctx.beginPath();
      ctx.arc(hx + hw*0.35, hy + hh*0.40, 1.6, 0, Math.PI*2);
      ctx.arc(hx + hw*0.65, hy + hh*0.40, 1.6, 0, Math.PI*2);
      ctx.fill();

      ctx.globalAlpha = 0.35;
      ctx.fillStyle = "#ffffff";
      ctx.beginPath();
      ctx.ellipse(hx + hw*0.70, hy + hh*0.25, 5.5, 3.0, -0.2, 0, Math.PI*2);
      ctx.fill();
      ctx.globalAlpha = 1;
    }
  }
}

function drawLevelBanner(){
  if(state.banner <= 0) return;

  const alpha = Math.min(1, state.banner / 40);
  const bw = 300, bh = 66;
  const bx = (W - bw) / 2;
  const by = 34;

  ctx.save();
  ctx.globalAlpha = alpha;

  ctx.fillStyle = "rgba(15,23,42,0.90)";
  roundedRectPath(ctx, bx, by, bw, bh, 14);
  ctx.fill();

  ctx.shadowColor = "rgba(56,189,248,0.55)";
  ctx.shadowBlur = 12;
  ctx.strokeStyle = "#38bdf8";
  ctx.lineWidth = 2;
  roundedRectPath(ctx, bx + 0.5, by + 0.5, bw - 1, bh - 1, 14);
  ctx.stroke();
  ctx.shadowBlur = 0;

  ctx.fillStyle = "#f9fafb";
  ctx.font = "800 22px Lato";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("Nivel " + state.level, W/2, by + bh/2);

  ctx.restore();
}

function drawSwoosh(){
  if(state.swoosh <= 0 && state.swooshFlash <= 0) return;

  // flash
  if(state.swooshFlash > 0){
    const a = state.swooshFlash / 12;
    ctx.globalAlpha = 0.18 * a;
    ctx.fillStyle = "#38bdf8";
    ctx.fillRect(0,0,W,H);
    ctx.globalAlpha = 1;
  }

  // speed lines
  if(state.swoosh > 0){
    const a = state.swoosh / 28;
    ctx.save();
    ctx.globalAlpha = 0.24 * a;
    ctx.strokeStyle = "#93c5fd";
    ctx.lineWidth = 2;

    for(let i=0;i<18;i++){
      const y = 40 + i * 26;
      const x1 = rand(40, W*0.25);
      const x2 = rand(W*0.70, W-40);
      ctx.beginPath();
      ctx.moveTo(x1, y + rand(-6,6));
      ctx.lineTo(x2, y + rand(-6,6));
      ctx.stroke();
    }
    ctx.restore();
  }
}

function drawGameOver(){
  ctx.fillStyle = "rgba(10, 15, 30, 0.76)";
  ctx.fillRect(0, 0, W, H);

  const bw = 560, bh = 170;
  const bx = (W - bw) / 2;
  const by = (H - bh) / 2 - 8;

  ctx.save();
  ctx.shadowColor = "rgba(56,189,248,0.35)";
  ctx.shadowBlur = 22;

  ctx.fillStyle = "rgba(15,23,42,0.90)";
  roundedRectPath(ctx, bx, by, bw, bh, 18);
  ctx.fill();

  ctx.shadowBlur = 0;
  ctx.strokeStyle = "rgba(56,189,248,0.75)";
  ctx.lineWidth = 2;
  roundedRectPath(ctx, bx + 0.5, by + 0.5, bw - 1, bh - 1, 18);
  ctx.stroke();

  ctx.fillStyle = "#f9fafb";
  ctx.font = "900 30px Lato";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("Juego terminado", W / 2, by + 54);

  ctx.font = "700 16px Lato";
  ctx.fillText(`Puntaje: ${state.score}  |  Nivel: ${state.level}  |  Monedas: ${state.coins}`, W / 2, by + 96);

  ctx.font = "600 13px Lato";
  ctx.fillStyle = "rgba(249,250,251,0.85)";
  ctx.fillText(`Pulsa "Reintentar" (o Enter / R) para jugar de nuevo.`, W / 2, by + 128);

  ctx.restore();
}

/* ---------------------------------------------------------
 *  MAIN DRAW LOOP (RAF)
 * --------------------------------------------------------- */
function update(){
  state.frame++;
  if(state.shake > 0) state.shake--;
  if(state.banner > 0) state.banner--;
  if(state.swoosh > 0) state.swoosh--;
  if(state.swooshFlash > 0) state.swooshFlash--;

  updateParticles();
}

function draw(){
  const shake = applyShake();

  ctx.save();
  ctx.clearRect(0,0,W,H);
  ctx.translate(shake.x, shake.y);

  drawBoardBackground();
  drawWalls3D();          // NUEVO: paredes 3D
  drawCoinLikeRunner();   // moneda igual al runner
  drawParticles();        // NUEVO: part√≠culas
  drawSnake3D();          // snake 3D
  drawLevelBanner();      // banner nivel
  drawSwoosh();           // NUEVO: swoosh al subir nivel

  if(!state.playing) drawGameOver();

  ctx.restore();
}

function raf(){
  update();
  draw();
  requestAnimationFrame(raf);
}

/* ---------------------------------------------------------
 *  START
 * --------------------------------------------------------- */
resetGame();
raf();

})();
</script>
</body>
</html>
