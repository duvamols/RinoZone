<!doctype html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <!-- Viewport optimizado para m√≥vil + safe areas -->
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>Mundo de Monedas ¬∑ Turbo</title>

  <style>
    :root{
      /* Paleta m√°s ‚Äúgaming premium‚Äù (alto contraste + ne√≥n controlado) */
      --bg0:#05060d;
      --bg1:#0b1020;
      --bg2:#020617;

      --panel: rgba(15, 23, 42, 0.82);
      --panel2: rgba(2, 6, 23, 0.55);
      --stroke: rgba(148, 163, 184, 0.18);

      --text:#f8fafc;
      --muted:#cbd5f5;

      --accent:#38bdf8;
      --accent2:#a78bfa;

      --gold:#facc15;
      --green:#22c55e;
      --red:#fb7185;
      --amber:#f59e0b;
    }

    *{
      box-sizing:border-box;
      margin:0;
      padding:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, "Helvetica Neue", Arial, "Apple Color Emoji","Segoe UI Emoji";
    }

    html, body{ height:100%; width:100%; }

    body{
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      color:var(--text);
      padding:16px;
      overflow:hidden;
      touch-action:none;
      -webkit-user-select:none;
      user-select:none;

      background:
        radial-gradient(1100px 520px at 18% 12%, rgba(56,189,248,0.18), transparent 60%),
        radial-gradient(900px 500px at 82% 18%, rgba(167,139,250,0.18), transparent 60%),
        radial-gradient(1000px 600px at 50% 88%, rgba(250,204,21,0.10), transparent 60%),
        linear-gradient(180deg, var(--bg1), var(--bg2));
    }

    #app{
      position:relative;
      width:100%;
      display:flex;
      justify-content:center;
    }

    /* ‚ÄúApp shell‚Äù */
    .game-wrapper{
      width:100%;
      max-width:1200px;
      background: linear-gradient(180deg, var(--panel), rgba(15,23,42,0.68));
      border:1px solid var(--stroke);
      border-radius:26px;
      box-shadow:
        0 26px 70px rgba(0,0,0,.48),
        inset 0 1px 0 rgba(255,255,255,0.06);
      padding:16px 16px 18px;
      display:flex;
      flex-direction:column;
      gap:12px;
      position:relative;
      overflow:hidden;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }

    /* brillo diagonal sutil */
    .game-wrapper::before{
      content:"";
      position:absolute;
      inset:-40% -30%;
      background: linear-gradient(120deg,
        transparent 35%,
        rgba(255,255,255,0.05) 46%,
        transparent 58%);
      transform: rotate(10deg);
      pointer-events:none;
    }

    .topbar{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
      position:relative;
      z-index:2;
    }

    .brand{
      display:flex;
      align-items:center;
      gap:10px;
      min-width: 0;
      flex: 1 1 auto;
    }

    .logo{
      width:40px;
      height:40px;
      border-radius:14px;
      display:grid;
      place-items:center;
      background:
        radial-gradient(20px 20px at 30% 30%, rgba(255,255,255,0.28), transparent 60%),
        linear-gradient(135deg, rgba(56,189,248,0.95), rgba(167,139,250,0.95));
      box-shadow: 0 10px 22px rgba(0,0,0,0.35);
      border:1px solid rgba(255,255,255,0.18);
      font-weight: 1000;
      letter-spacing:.4px;
    }

    .brand h1{
      font-size:16px;
      font-weight:900;
      letter-spacing:.2px;
      margin-bottom:1px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width: 44vw;
    }
    .brand p{
      font-size:12px;
      color: rgba(203,213,245,0.92);
      line-height:1.25;
      max-width: 560px;
    }

    .actions{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:nowrap;
      justify-content:flex-end;
      overflow-x:auto;
      -webkit-overflow-scrolling:touch;
      scrollbar-width:none;
      max-width: 56vw;
    }
    .actions::-webkit-scrollbar{ display:none; }
    .actions .btn{ flex:0 0 auto; }

    .chip{
      display:flex;
      align-items:center;
      gap:8px;
      padding:6px 8px;
      border-radius:12px;
      background: rgba(2,6,23,0.45);
      border:1px solid rgba(148,163,184,0.18);
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.05);
      font-size:11px;
      white-space:nowrap;

      font-weight:800;
      color: rgba(248,250,252,0.95);
      white-space:nowrap;
    }
    
    .chip-coin{
      background: linear-gradient(180deg, rgba(56,189,248,0.20), rgba(2,6,23,0.45));
      border-color: rgba(56,189,248,0.30);
    }
    .chip-coin b{ color: var(--gold); }
    .chip-best{
      background: rgba(2,6,23,0.38);
      border-color: rgba(167,139,250,0.30);
    }

.chip b{ color: var(--gold); }

    .btn{
      border:none;
      border-radius:14px;
      padding:9px 12px;
      font-size:12px;
      font-weight:900;
      cursor:pointer;
      color:var(--text);
      background: rgba(255,255,255,0.10);
      border:1px solid rgba(255,255,255,0.14);
      transition:transform .12s ease, filter .12s ease, background .12s ease;
      user-select:none;
      display:inline-flex;
      align-items:center;
      gap:8px;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
    }
    .btn:hover{ transform: translateY(-1px); filter: brightness(1.03); background: rgba(255,255,255,0.12); }
    .btn:active{ transform: translateY(1px); }

    .btn-primary{
      background: linear-gradient(135deg, rgba(56,189,248,0.92), rgba(167,139,250,0.92));
      border:1px solid rgba(255,255,255,0.20);
    }

    .btn-danger{
      background: linear-gradient(135deg, rgba(251,113,133,0.92), rgba(245,158,11,0.70));
      border:1px solid rgba(255,255,255,0.18);
    }

    .btn-volver{
      background: rgba(226,232,240,0.90);
      color:#0b1020;
      border:1px solid rgba(255,255,255,0.35);
    }

    .hudrow{
      display:flex;
      align-items:center;
      justify-content:flex-start;
      gap:10px;
      flex-wrap:nowrap;
      position:relative;
      z-index:2;
      margin-top:2px;
      overflow:hidden;
    }


    .hud-left, .hud-right{
      display:flex;
      gap:10px;
      flex-wrap:nowrap;
      align-items:center;
      align-items:center;
    }

    .meter{
      width: 220px;
      height: 12px;
      border-radius: 999px;
      background: rgba(2,6,23,0.45);
      border: 1px solid rgba(148,163,184,0.18);
      overflow:hidden;
      position:relative;
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.05);
    }
    .meter > i{
      display:block;
      height:100%;
      width:0%;
      border-radius: 999px;
      background: linear-gradient(90deg, rgba(250,204,21,0.95), rgba(56,189,248,0.95), rgba(167,139,250,0.95));
      box-shadow: 0 0 16px rgba(56,189,248,0.22);
      transition: width .10s linear;
    }

    .game-container{
      margin-top:6px;
      background:
        radial-gradient(900px 260px at 50% 0%, rgba(56,189,248,0.14), transparent 60%),
        linear-gradient(180deg, rgba(2,6,23,0.60), rgba(2,6,23,0.35));
      border-radius:22px;
      overflow:hidden;
      padding:0;
      box-shadow:
        inset 0 0 0 1px rgba(15,23,42,.35),
        0 20px 40px rgba(0,0,0,0.28);
      display:flex;
      flex-direction:column;
      gap:8px;
      position:relative;
    }

    
/* HUD overlay sobre el cielo (no reduce el tama√±o del juego) */
.game-container .topbar,
.game-container .hudrow{
  position:absolute;
  left:12px;
  right:12px;
  z-index:8;
  pointer-events:none; /* el juego sigue recibiendo taps */
}
.game-container .topbar{ top:12px; }
.game-container .hudrow{ top:82px; }

/* Los botones s√≠ deben poder clicarse */
.game-container .topbar .btn,
.game-container .topbar button,
.game-container .hudrow .chip,
.game-container .hudrow .meter{
  pointer-events:auto;
}

/* Oculta la barra de controles para no tapar el juego (se mantiene el bot√≥n Reintentar del overlay) */
.help{ display:none !important; }

canvas{
      display:block;
      margin:0 auto;
      width:100%;
      max-width:none;
      height:100%;
      border-radius:18px;
      background: radial-gradient(820px 260px at 50% 10%, rgba(255,255,255,0.08), transparent 60%),
                  linear-gradient(180deg, #60a5fa, #0ea5e9);
      touch-action:none;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.06);
    }

    /* Help overlay */
    .help{
      font-size:12px;
      color:rgba(203,213,245,0.92);
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      flex-wrap:wrap;
      padding:8px 10px;
      border-radius:16px;
      background: rgba(2,6,23,0.35);
      border: 1px solid rgba(148,163,184,0.14);
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.05);
    }
    .help kbd{
      font: 900 11px/1 system-ui;
      padding:4px 7px;
      border-radius:10px;
      background: rgba(255,255,255,0.10);
      border: 1px solid rgba(255,255,255,0.14);
      color: rgba(248,250,252,0.95);
    }

    .btn-restart{
      display:none;
    }

    /* Overlays (start / rotate / gameover) */
    .overlay{
      position:absolute;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      padding:24px;
      z-index:50;
      background: rgba(0,0,0,0.70);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    .overlay.show{ display:flex; }
    #rotateHint{ z-index: 70; }


    .card{
      width:min(560px, 94vw);
      border-radius:24px;
      padding:18px 18px 16px;
      background: rgba(15,23,42,0.92);
      border:1px solid rgba(56,189,248,0.26);
      box-shadow: 0 22px 60px rgba(0,0,0,0.55);
      text-align:left;
      display:flex;
      gap:14px;
      align-items:flex-start;
    }
    .card .icon{
      width:56px;
      height:56px;
      border-radius:18px;
      display:grid;
      place-items:center;
      flex: 0 0 auto;
      background: radial-gradient(20px 20px at 30% 30%, rgba(255,255,255,0.22), transparent 60%),
                  linear-gradient(135deg, rgba(56,189,248,0.95), rgba(167,139,250,0.95));
      border:1px solid rgba(255,255,255,0.16);
    }
    .card h2{
      font-size:18px;
      font-weight:1000;
      letter-spacing:.2px;
      margin-bottom:6px;
    }
    .card p{
      font-size:13px;
      font-weight:650;
      color: rgba(203,213,245,0.92);
      line-height:1.35;
      margin-bottom:10px;
    }
    .card .row{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
    }
    .card .mini{
      font-size:12px;
      color: rgba(203,213,245,0.88);
      line-height:1.35;
      margin-top:8px;
    }

    /* Rotate hint overlay uses same card */
    #rotateHint{ z-index:60; }

    /* iOS Hint */
    #iosHint{
      position:absolute;
      left:12px;
      right:12px;
      top:12px;
      z-index:70;
      display:none;
      padding:10px 12px;
      border-radius:16px;
      background:rgba(15,23,42,0.92);
      border:1px solid rgba(56,189,248,0.24);
      color:#f9fafb;
      font:700 12px/1.25 system-ui, -apple-system, Segoe UI, Roboto, Arial;
      box-shadow:0 14px 30px rgba(0,0,0,0.35);
    }
    #iosHint .row{ display:flex; align-items:flex-start; gap:10px; }
    #iosHint .ttl{ font-size:13px; font-weight:1000; margin-bottom:2px; }
    #iosHint .mut{ color:rgba(203,213,245,0.92); font-weight:650; }
    #iosHint .x{
      margin-left:auto;
      border:0;
      background:rgba(255,255,255,0.10);
      color:#fff;
      border-radius:10px;
      padding:6px 8px;
      font:900 12px system-ui;
      cursor:pointer;
      flex:0 0 auto;
    }

    /* Mobile layout: full screen app */
    @media (max-width: 820px){
      body{
        padding:0;
        align-items:stretch;
        justify-content:stretch;
      }
      #app{
        position:fixed;
        inset:0;
        padding: env(safe-area-inset-top) env(safe-area-inset-right)
                 env(safe-area-inset-bottom) env(safe-area-inset-left);
      }
      .game-wrapper{
        max-width:none;
        width:100%;
        height:100%;
        border-radius:0;
        box-shadow:none;
        padding:12px;
        border-left:0; border-right:0;
      }
      .brand p{ display:none; } /* gana espacio */
      .meter{ width: 180px; }
      .game-container{ flex:1; }
      .help{ font-size:11px; }
    }

    /* Landscape m√≥vil: maximiza canvas */
    @media (max-width: 920px) and (orientation: landscape){
      .game-wrapper{ padding:10px 10px 12px; }
      .brand h1{ font-size:14px; }
      .actions{ gap:8px; }
      .chip{ padding:7px 9px; font-size:11px; border-radius:13px; }
      .meter{ width: 200px; }
      .game-container{ padding:8px; border-radius:18px; }
      .help{
        position:absolute;
        left:10px; right:10px; bottom:10px;
        margin:0;
        font-size:11px;
        background: rgba(15,23,42,0.46);
        backdrop-filter: blur(8px);
        -webkit-backdrop-filter: blur(8px);
      }
      canvas{ max-width:none; }
    }

    @media (max-width: 420px){
      .card{ flex-direction:column; text-align:center; align-items:center; }
      .card .row{ justify-content:center; }
    }
  </style>
</head>

<body>
  <div id="app">
    <div class="game-wrapper">
      <div class="game-container" id="gameContainer">
<div class="topbar">
        <div class="brand" aria-label="Encabezado del juego">
          <div class="logo" aria-hidden="true">MM</div>
          <div>
            <h1>Mundo de Monedas ¬∑ Turbo</h1>
            <p>Runner competitivo: encadena monedas para multiplicar puntos. Un fallo te corta la racha.</p>
          </div>
        </div>

        <div class="actions">
          <button class="btn btn-volver" id="btnBack" type="button">‚¨Ö Volver</button>
          <button class="btn" id="btnSound" type="button" aria-pressed="true" title="Activar/Desactivar sonido">üîä Sonido</button>
          <button class="btn" id="btnVibrate" type="button" aria-pressed="true" title="Vibraci√≥n (m√≥vil)">üì≥ Vibraci√≥n</button>
          <button class="btn btn-primary" id="btnStartTop" type="button">‚ñ∂ Jugar</button>
        </div>
      </div>

            <div class="hudrow">
        <div class="hud-left">
          <div class="chip chip-coin">ü™ô Monedas: <b id="hudCoins">0</b></div>
          <div class="chip chip-best">R√©cord: <b id="hudBestCoins">0</b></div>
        </div>
      </div>

      <canvas id="gameCanvas" width="840" height="320"></canvas>

        <div class="help">
          <span>
            Controles: <kbd>Espacio</kbd> / <kbd>‚Üë</kbd> / tocar para saltar (doble salto).
            Consejo: encadena monedas sin fallar para subir el multiplicador.
          </span>
          <button id="btnRestart" class="btn btn-danger btn-restart" type="button">‚Üª Reintentar</button>
        </div>

        <!-- Start overlay -->
        <div id="startOverlay" class="overlay show" role="dialog" aria-modal="true">
          <div class="card">
            <div class="icon" aria-hidden="true">‚ö°</div>
            <div>
              <h2>Listo para competir</h2>
              <p>
                Juega r√°pido. Todo gira en torno a las <b>monedas</b>: recoge, encadena y mant√©n la racha.
                Entre m√°s monedas seguidas logres, mayor ser√° el <b>bono</b> de recompensa.
              </p>
              <div class="row">
                <button class="btn btn-primary" id="btnStart" type="button">‚ñ∂ Empezar</button>
                <button class="btn" id="btnHow" type="button">¬øC√≥mo ganar?</button>
              </div>
              <div class="mini" id="howText" style="display:none">
                ‚Ä¢ Mant√©n la racha: recoge monedas sin fallar para sostener el bono.<br/>
                ‚Ä¢ Bloques: un choque termina la partida (o consume escudo si lo tienes).<br/>
                ‚Ä¢ A mayor tiempo vivo, m√°s velocidad y m√°s patrones.
              </div>
            </div>
          </div>
        </div>

        <!-- Rotate overlay -->
        <div id="rotateHint" class="overlay" aria-hidden="true">
          <div class="card">
            <div class="icon" aria-hidden="true">‚Üî</div>
            <div>
              <h2>Gira el tel√©fono</h2>
              <p>Para una experiencia m√°s intensa, usa el modo horizontal. Al girar, el juego se ajusta autom√°ticamente.</p>
              <div class="mini">En iPhone, para verlo tipo app sin barras: Compartir ‚Üí A√±adir a pantalla de inicio.</div>
            </div>
          </div>
        </div>

        <!-- Gameover overlay -->
        <div id="gameOverOverlay" class="overlay" aria-hidden="true">
          <div class="card">
            <div class="icon" aria-hidden="true">üèÅ</div>
            <div>
              <h2 id="goTitle">Fin de partida</h2>
              <p id="goStats">‚Äî</p>
              <div class="row">
                <button class="btn btn-primary" id="btnRestart2" type="button">‚Üª Reintentar</button>
                <button class="btn" id="btnShare" type="button">üì§ Compartir</button>
              </div>
              <div class="mini">Tip: si tu combo se cae, prioriza la siguiente moneda para reactivarlo r√°pido.</div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div id="iosHint" style="display:none"></div>
  </div>

  <script>
    (() => {
      "use strict";

      /* ---------------------------------------------------------
       *  RESPONSIVE FIT
       * --------------------------------------------------------- */
      const canvas = document.getElementById("gameCanvas");
      const gameContainer = document.getElementById("gameContainer");
      const rotateHint = document.getElementById("rotateHint");
      const startOverlay = document.getElementById("startOverlay");
      const gameOverOverlay = document.getElementById("gameOverOverlay");
      const iosHint = document.getElementById("iosHint");
      let awaitingLandscapeTap = false;

      const GAME_W = canvas.width;
      const GAME_H = canvas.height;

      function isIOS() {
        return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream;
      }
      function isStandalone() {
        return (window.navigator.standalone === true) || window.matchMedia("(display-mode: standalone)").matches;
      }
      function showIOSHint() {
        if (!iosHint) return;
        const vw = window.innerWidth;
        const isMobile = Math.min(window.innerWidth, window.innerHeight) <= 900;
        if (isIOS() && isMobile && !isStandalone()) {
          iosHint.style.display = "block";
          iosHint.innerHTML = `
            <div class="row">
              <div>
                <div class="ttl">iPhone (Safari)</div>
                <div class="mut">Safari no permite pantalla completa real en la web. Para verlo como app (sin barras), usa: <b>Compartir ‚Üí A√±adir a pantalla de inicio</b> y √°brelo desde ah√≠.</div>
              </div>
              <button class="x" type="button" aria-label="Cerrar">‚úï</button>
            </div>
          `;
          iosHint.querySelector(".x")?.addEventListener("click", () => (iosHint.style.display = "none"), { once:true });
        } else {
          iosHint.style.display = "none";
        }
      }

      function applyFit() {
        const containerRect = gameContainer.getBoundingClientRect();
        const helpEl = gameContainer.querySelector(".help");
        const isLandscape = window.innerWidth > window.innerHeight;
        const isMobile = Math.min(window.innerWidth, window.innerHeight) <= 900;

        const helpH = (isMobile && isLandscape) ? 0 : (helpEl ? helpEl.getBoundingClientRect().height : 0);
        const styles = getComputedStyle(gameContainer);
        const padY = parseFloat(styles.paddingTop || "0") + parseFloat(styles.paddingBottom || "0");
        const padX = parseFloat(styles.paddingLeft || "0") + parseFloat(styles.paddingRight || "0");

        const availW = Math.max(0, containerRect.width - padX);
        const availH = Math.max(0, containerRect.height - padY - helpH - 8);

        const scale = Math.max(availW / GAME_W, availH / GAME_H);

        canvas.style.width = Math.floor(GAME_W * scale) + "px";
        canvas.style.height = Math.floor(GAME_H * scale) + "px";

        // Rotate hint: prefer landscape on mobile
        const vw = window.innerWidth;
        const vh = window.innerHeight;
        const isPortrait = vh > vw;
        const preferLandscape = true;

        rotateHint.classList.toggle("show", (isMobile && preferLandscape && isPortrait));
        rotateHint.setAttribute("aria-hidden", rotateHint.classList.contains("show") ? "false" : "true");

        // minimize browser bars
        window.scrollTo(0, 1);
        showIOSHint();

        // Fullscreen (Android/Chrome y similares): al girar a horizontal, arma la petici√≥n para el pr√≥ximo toque
        const vw2 = window.innerWidth, vh2 = window.innerHeight;
        const isMobile2 = vw2 <= 820;
        const isLandscape2 = vw2 > vh2;
        if (isMobile2 && isLandscape2 && !isIOS() && !document.fullscreenElement) {
          awaitingLandscapeTap = true;
          // si ya hubo interacci√≥n previa, intenta tambi√©n en caliente
          maybeAutoFullscreen();
        } else {
          awaitingLandscapeTap = false;
        }
      }

      window.addEventListener("resize", () => setTimeout(applyFit, 60), { passive:true });
      window.addEventListener("orientationchange", () => setTimeout(applyFit, 160), { passive:true });
      document.addEventListener("fullscreenchange", () => setTimeout(applyFit, 60));
      window.addEventListener("touchend", () => setTimeout(applyFit, 60), { passive:true });

      applyFit();
      showIOSHint();

      /* ---------------------------------------------------------
       *  DOM / HUD
       * --------------------------------------------------------- */
      const ctx = canvas.getContext("2d", { alpha: true });

      const hudCoins = document.getElementById("hudCoins");
      const hudBestCoins = document.getElementById("hudBestCoins");
      // UI enfocada en monedas (puntaje/nivel siguen internos)
      const btnRestart = document.getElementById("btnRestart");
      const btnRestart2 = document.getElementById("btnRestart2");

      const btnBack = document.getElementById("btnBack");
      const btnSound = document.getElementById("btnSound");
      const btnVibrate = document.getElementById("btnVibrate");
      const btnStartTop = document.getElementById("btnStartTop");
      const btnStart = document.getElementById("btnStart");
      const btnHow = document.getElementById("btnHow");
      const howText = document.getElementById("howText");
      const btnShare = document.getElementById("btnShare");

      const goTitle = document.getElementById("goTitle");
      const goStats = document.getElementById("goStats");

      btnBack.addEventListener("click", () => {
        // Mantengo tu comportamiento original, pero robusto
        window.location.href = "panel.html";
      });

      btnHow.addEventListener("click", () => {
        howText.style.display = (howText.style.display === "none") ? "block" : "none";
      });

      /* ---------------------------------------------------------
       *  PERSISTENCIA (mejor puntaje local)
       * --------------------------------------------------------- */
      const BEST_COINS_KEY = "mm_turbo_best_coins";
      const getBestCoins = () => Math.floor(Number(localStorage.getItem(BEST_COINS_KEY) || "0")) || 0;
      const setBestCoins = (v) => localStorage.setItem(BEST_COINS_KEY, String(v|0));

      let bestCoins = getBestCoins();
      if (hudBestCoins) hudBestCoins.textContent = String(bestCoins);
/* ---------------------------------------------------------
       *  CONFIG (m√°s competitivo)
       * --------------------------------------------------------- */
      const W = canvas.width;
      const H = canvas.height;

      const GRAVITY = 1.65;
      const JUMP_FORCE = 20.2;
      const MAX_JUMPS = 2;

      // Puntuaci√≥n: ahora mezcla distancia + monedas, con multiplicador por combo
      const BASE_DISTANCE_RATE = 0.26;      // pts por frame (escala con speed)
      const SCORE_PER_COIN = 12;

      // Progresi√≥n: m√°s r√°pida, pero controlada
      // Progresi√≥n: m√°s emocionante (sube m√°s lento y exige m√°s a medida que avanzas)
      const BASE_LEVEL_POINTS = 900;      // puntos para pasar de nivel 1‚Üí2 (antes 320)
      const LEVEL_POINTS_STEP = 140;       // cada nivel requiere +step puntos extra
      const BASE_SPEED = 4.8;
      const SPEED_PER_LEVEL = 0.42;

      function computeLevelFromScore(scoreInt){
        // Serie aritm√©tica acumulada: sum_{k=0..n-2} (BASE + k*STEP)
        let lvl = 1;
        let need = BASE_LEVEL_POINTS; // puntos necesarios para llegar al nivel 2
        let k = 0;
        while (scoreInt >= need){
          lvl++;
          k++;
          need += (BASE_LEVEL_POINTS + k * LEVEL_POINTS_STEP);
          if (lvl > 99) break;
        }
        return lvl;
      }

      const GROUND_HEIGHT = 52;
      const groundY = H - GROUND_HEIGHT;

      // Combo: ventana de tiempo para encadenar monedas
      const COMBO_WINDOW_FRAMES = 150; // ~2.5s a 60fps
      const COMBO_MAX = 12;            // cap por balance
      const COMBO_TIER = [1,2,3,4,5,6,8,10,12,14,16,18]; // multiplicador por nivel de combo (1..12)

      // Powerups (raros): escudo
      const POWERUP_EVERY = 520;       // cada N frames en promedio, luego random
      const POWERUP_CHANCE = 0.55;     // chance cuando toca el frame
      const SHIELD_DURATION_FRAMES = 360; // 6s

      // Spawn base (se ajusta din√°micamente con nivel)
      const SPAWN = {
        coinEvery: 70,
        blockEvery: 108
      };

      /* ---------------------------------------------------------
       *  UTILS
       * --------------------------------------------------------- */
      const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
      const rand = (a, b) => a + Math.random() * (b - a);
      const lerp = (a, b, t) => a + (b - a) * t;

      function roundedRectPath(g, x, y, w, h, r) {
        const rr = Math.min(r, w / 2, h / 2);
        g.beginPath();
        g.moveTo(x + rr, y);
        g.lineTo(x + w - rr, y);
        g.quadraticCurveTo(x + w, y, x + w, y + rr);
        g.lineTo(x + w, y + h - rr);
        g.quadraticCurveTo(x + w, y + h, x + w - rr, y + h);
        g.lineTo(x + rr, y + h);
        g.quadraticCurveTo(x, y + h, x, y + h - rr);
        g.lineTo(x, y + rr);
        g.quadraticCurveTo(x, y, x + rr, y);
        g.closePath();
      }

      function vibrate(ms){
        if (!vibrationOn) return;
        if (navigator.vibrate) navigator.vibrate(ms);
      }

      /* ---------------------------------------------------------
       *  AUDIO (premium + control)
       * --------------------------------------------------------- */
      let audioEnabled = false;    // se habilita con primer gesto
      let fxCtx = null;

      function getFxCtx() {
        if (!fxCtx) {
          const AC = window.AudioContext || window.webkitAudioContext;
          if (AC) fxCtx = new AC();
        }
        return fxCtx;
      }

      function fxBeep(steps, dur = 0.22, vol = 0.16, type = "triangle", filterHz = 1800) {
        if (!audioEnabled) return;
        const ac = getFxCtx();
        if (!ac) return;

        if (ac.state === "suspended") ac.resume();

        const now = ac.currentTime;
        const osc = ac.createOscillator();
        const gain = ac.createGain();
        const filter = ac.createBiquadFilter();

        osc.type = type;
        filter.type = "lowpass";
        filter.frequency.setValueAtTime(filterHz, now);

        gain.gain.setValueAtTime(vol, now);
        gain.gain.exponentialRampToValueAtTime(0.001, now + dur);

        osc.connect(filter);
        filter.connect(gain);
        gain.connect(ac.destination);

        for (const s of steps) osc.frequency.setValueAtTime(s.freq, now + s.time);

        osc.start(now);
        osc.stop(now + dur + 0.02);
      }

      function playFx(kind) {
        switch (kind) {
          case "jump":
            fxBeep([{ time: 0.00, freq: 520 }, { time: 0.05, freq: 680 }, { time: 0.10, freq: 820 }], 0.18, 0.14, "triangle", 2200);
            break;
          case "coin":
            fxBeep([{ time: 0.00, freq: 980 }, { time: 0.05, freq: 1250 }, { time: 0.10, freq: 1560 }], 0.16, 0.16, "triangle", 2800);
            break;
          case "combo":
            fxBeep([{ time: 0.00, freq: 740 }, { time: 0.05, freq: 880 }, { time: 0.10, freq: 1040 }], 0.18, 0.16, "sine", 2600);
            break;
          case "power":
            fxBeep([{ time: 0.00, freq: 420 }, { time: 0.06, freq: 540 }, { time: 0.12, freq: 720 }], 0.22, 0.16, "triangle", 2400);
            break;
          case "shieldBreak":
            fxBeep([{ time: 0.00, freq: 520 }, { time: 0.06, freq: 320 }, { time: 0.12, freq: 220 }], 0.22, 0.17, "square", 1600);
            break;
          case "hit":
            fxBeep([{ time: 0.00, freq: 260 }, { time: 0.05, freq: 190 }, { time: 0.10, freq: 140 }], 0.25, 0.18, "square", 1400);
            break;
          case "levelup":
            fxBeep([{ time: 0.00, freq: 660 }, { time: 0.07, freq: 880 }, { time: 0.14, freq: 1180 }], 0.22, 0.16, "triangle", 2800);
            break;
          case "lose": {
            if (!audioEnabled) return;
            const ac = getFxCtx();
            if (!ac) return;
            if (ac.state === "suspended") ac.resume();

            const now = ac.currentTime;
            const osc = ac.createOscillator();
            const gain = ac.createGain();
            const filter = ac.createBiquadFilter();

            osc.type = "square";
            filter.type = "lowpass";
            filter.frequency.setValueAtTime(1600, now);
            filter.frequency.exponentialRampToValueAtTime(220, now + 0.75);

            gain.gain.setValueAtTime(0.20, now);
            gain.gain.exponentialRampToValueAtTime(0.001, now + 0.85);

            osc.connect(filter);
            filter.connect(gain);
            gain.connect(ac.destination);

            osc.frequency.setValueAtTime(480, now);
            osc.frequency.exponentialRampToValueAtTime(105, now + 0.85);

            osc.start(now);
            osc.stop(now + 0.9);
            break;
          }
        }
      }

      // M√∫sica procedural ligera (se acelera levemente con el nivel)
      let musicCtx = null;
      let musicGain = null;
      let musicTimer = null;
      let musicOn = false;

      const levelMelodies = [
        [330, 392, 440, 392, 330, 262, 294, 330],
        [523, 494, 440, 392, 440, 494, 523, 587],
        [659, 587, 523, 587, 659, 784, 698, 659],
        [392, 440, 494, 523, 494, 440, 392, 330],
        [880, 740, 660, 740, 880, 660, 550, 660]
      ];

      function ensureMusic() {
        if (!audioEnabled) return;
        const AC = window.AudioContext || window.webkitAudioContext;
        if (!musicCtx) {
          musicCtx = new AC();
          musicGain = musicCtx.createGain();
          musicGain.gain.value = 0.10;
          musicGain.connect(musicCtx.destination);
        }
      }

      function playNote(freq, dur = 0.22) {
        if (!audioEnabled) return;
        const osc = musicCtx.createOscillator();
        const gain = musicCtx.createGain();
        osc.type = "triangle";
        osc.frequency.setValueAtTime(freq, musicCtx.currentTime);

        gain.gain.setValueAtTime(0.18, musicCtx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.001, musicCtx.currentTime + dur);

        osc.connect(gain);
        gain.connect(musicGain);

        osc.start();
        osc.stop(musicCtx.currentTime + dur);
      }

      function melodyForLevel(lvl) {
        return levelMelodies[(lvl - 1) % levelMelodies.length];
      }

      function musicStart(getLevelFn) {
        if (!audioEnabled) return;
        ensureMusic();
        if (musicOn) return;
        musicOn = true;

        let step = 0;
        if (musicTimer) clearInterval(musicTimer);

        musicTimer = setInterval(() => {
          const melody = melodyForLevel(getLevelFn());
          playNote(melody[step % melody.length], 0.22);
          step++;
        }, 250);
      }

      function musicStop() {
        musicOn = false;
        if (musicTimer) {
          clearInterval(musicTimer);
          musicTimer = null;
        }
      }

      /* ---------------------------------------------------------
       *  GAME STATE
       * --------------------------------------------------------- */
      const state = {
        speed: BASE_SPEED,
        frame: 0,
        score: 0,
        coins: 0,
        level: 1,
        playing: false,     // empieza en pausa hasta "Start"
        banner: 0,
        shake: 0,

        // competitivo
        distance: 0,
        combo: 0,
        comboT: 0,          // frames restantes
        multiplier: 1,

        // powerups
        shield: 0,          // frames restantes
        lastCoinFrame: -9999
      };

      const player = {
        x: 96,
        y: groundY - 42,
        w: 34,
        h: 42,
        vy: 0,
        jumps: 0,
        bob: 0
      };

      const coins = [];
      const blocks = [];
      const powerups = []; // {x,y,r,type}
      const particles = [];

      const layers = {
        stars: [],
        clouds: [],
        hillsFar: [],
        hillsMid: [],
        hillsNear: []
      };

      /* ---------------------------------------------------------
       *  WORLD GEN
       * --------------------------------------------------------- */
      function seedWorld() {
        layers.stars.length = 0;
        layers.clouds.length = 0;
        layers.hillsFar.length = 0;
        layers.hillsMid.length = 0;
        layers.hillsNear.length = 0;

        for (let i = 0; i < 54; i++) {
          layers.stars.push({
            x: Math.random() * W,
            y: Math.random() * (H * 0.58),
            r: rand(0.6, 1.9),
            tw: rand(0.01, 0.03),
            a: rand(0.30, 0.92)
          });
        }

        for (let i = 0; i < 7; i++) {
          layers.clouds.push({
            x: rand(0, W),
            y: rand(16, 108),
            w: rand(86, 160),
            h: rand(24, 48),
            s: rand(0.08, 0.18)
          });
        }

        for (let i = 0; i < 5; i++) {
          layers.hillsFar.push({
            x: i * 260,
            y: groundY - 92 - Math.random() * 46,
            w: 260,
            h: 116 + Math.random() * 58
          });
        }

        for (let i = 0; i < 4; i++) {
          layers.hillsMid.push({
            x: i * 290,
            y: groundY - 66 - Math.random() * 36,
            w: 290,
            h: 88 + Math.random() * 46
          });
        }

        for (let i = 0; i < 3; i++) {
          layers.hillsNear.push({
            x: i * 330,
            y: groundY - 46 - Math.random() * 30,
            w: 330,
            h: 74 + Math.random() * 42
          });
        }
      }

      /* ---------------------------------------------------------
       *  PARTICLES
       * --------------------------------------------------------- */
      function emitParticles(x, y, count, cfg = {}) {
        const {
          minVx = -1.8,
          maxVx = 1.8,
          minVy = -2.6,
          maxVy = -0.8,
          minR = 1.2,
          maxR = 3.2,
          life = 40,
          gravity = 0.08,
          drag = 0.985,
          color = "#e2e8f0"
        } = cfg;

        for (let i = 0; i < count; i++) {
          particles.push({
            x, y,
            vx: rand(minVx, maxVx),
            vy: rand(minVy, maxVy),
            r: rand(minR, maxR),
            life: life + Math.floor(rand(-8, 10)),
            t: 0,
            g: gravity,
            d: drag,
            c: color
          });
        }
      }

      function updateParticles() {
        for (let i = particles.length - 1; i >= 0; i--) {
          const p = particles[i];
          p.t++;
          p.vx *= p.d;
          p.vy = (p.vy + p.g) * p.d;
          p.x += p.vx;
          p.y += p.vy;
          if (p.t >= p.life) particles.splice(i, 1);
        }
      }

      function drawParticles() {
        for (const p of particles) {
          const a = 1 - (p.t / p.life);
          ctx.globalAlpha = a;
          ctx.beginPath();
          ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
          ctx.fillStyle = p.c;
          ctx.fill();
        }
        ctx.globalAlpha = 1;
      }

      /* ---------------------------------------------------------
       *  SPAWN
       * --------------------------------------------------------- */
      function dynamicSpawnEvery(base, min, lvl){
        // reduce interval as level increases; but keep within bounds
        const k = Math.max(0, lvl - 1);
        return Math.max(min, Math.floor(base - k * 2.2));
      }

      function spawnCoin() {
        const x = W + 20;
        let y = groundY - 70 - Math.random() * 78;
        y = clamp(y, 34, groundY - 54);

        // evita monedas ‚Äúimposibles‚Äù pegadas a bloque
        const danger = blocks.some(b => {
          const mx = 120;
          const overlapX = (x - mx) < (b.x + b.w) && (x + mx) > b.x;
          const overlapY = (y + 22) > b.y;
          return overlapX && overlapY;
        });
        if (danger) return;

        coins.push({
          x, y,
          r: 11,
          spin: rand(0, Math.PI * 2),
          collected: false,
          glow: rand(0.35, 0.85)
        });
      }

      function spawnBlock() {
        // patrones: normal / alto / doble (intenso pero justo)
        const pattern = Math.random();
        const baseH = 30 + Math.random() * 22;

        if (pattern < 0.68){
          blocks.push({
            x: W + 20,
            y: groundY - baseH,
            w: 34 + Math.random() * 26,
            h: baseH,
            kind: "normal"
          });
          return;
        }

        if (pattern < 0.88){
          const h = 44 + Math.random() * 26;
          blocks.push({
            x: W + 20,
            y: groundY - h,
            w: 34 + Math.random() * 22,
            h,
            kind: "tall"
          });
          return;
        }

        // doble bloque (espacio para pasar con timing)
        const h1 = baseH;
        const h2 = 28 + Math.random() * 18;
        const w1 = 34 + Math.random() * 18;
        const gap = 42 + Math.random() * 32;

        blocks.push({ x: W + 20, y: groundY - h1, w: w1, h: h1, kind: "normal" });
        blocks.push({ x: W + 20 + w1 + gap, y: groundY - h2, w: 30 + Math.random() * 18, h: h2, kind: "normal" });
      }

      function spawnShield() {
        const x = W + 20;
        const y = groundY - 95 - Math.random() * 70;
        powerups.push({
          x, y: clamp(y, 40, groundY - 80),
          r: 12,
          type: "shield",
          spin: rand(0, Math.PI*2)
        });
      }

      
      function updateLevelFromScore(){
        const scoreInt = Math.floor(state.score);
        const newLevel = computeLevelFromScore(scoreInt);
        if (newLevel <= state.level) return;

        state.level = newLevel;
        state.speed = BASE_SPEED + SPEED_PER_LEVEL * (state.level - 1);
        state.banner = 140;
        state.shake = Math.max(state.shake, 10);
// feedback visual/sonoro
        playFx("levelup");
        emitParticles(player.x + player.w*0.6, player.y + player.h*0.35, 26, {
          minVx: -2.6, maxVx: 2.6,
          minVy: -3.2, maxVy: -0.8,
          minR: 1.0, maxR: 3.2,
          life: 34,
          gravity: 0.09,
          color: "rgba(56,189,248,0.92)"
        });

        // acelera m√∫sica levemente con el nivel: reinicio sutil
        musicStop();
        if (audioEnabled) musicStart(() => state.level);
      }

/* ---------------------------------------------------------
       *  SCORING / COMBO
       * --------------------------------------------------------- */
      function setCombo(n){
        state.combo = clamp(n, 0, COMBO_MAX);
        state.multiplier = COMBO_TIER[Math.max(0, state.combo-1)] || 1;
}

      function bumpCombo(){
        // Si est√°s dentro de ventana, sube; si no, reinicia a 1
        if (state.comboT > 0) setCombo(state.combo + 1);
        else setCombo(Math.max(1, state.combo));

        state.comboT = COMBO_WINDOW_FRAMES;
        playFx(state.combo >= 3 ? "combo" : "coin");
      }

      function decayCombo(){
        if (state.comboT > 0){
          state.comboT--;
} else {
if (state.combo > 0){
            // ‚Äúcorta‚Äù la racha a x1, pero no borra monedas ni puntaje
            setCombo(1);
          }
        }
      }

      /* ---------------------------------------------------------
       *  RESET / START
       * --------------------------------------------------------- */
      function resetGame(hard = false) {
        state.speed = BASE_SPEED;
        state.frame = 0;
        state.score = 0;
        state.coins = 0;
        state.level = 1;
        state.banner = 0;
        state.shake = 0;

        state.distance = 0;
        state.combo = 0;
        state.comboT = 0;
        state.multiplier = 1;
        state.shield = 0;

        coins.length = 0;
        blocks.length = 0;
        powerups.length = 0;
        particles.length = 0;

        player.y = groundY - player.h;
        player.vy = 0;
        player.jumps = 0;
        player.bob = 0;

        if (hudCoins) hudCoins.textContent = "0";
        if (hudBestCoins) hudBestCoins.textContent = String(bestCoins|0);
        btnRestart.style.display = "none";

        seedWorld();
        musicStop();

        applyFit();

        if (hard){
          // en hard reset, vuelve a overlay
          state.playing = false;
          startOverlay.classList.add("show");
          gameOverOverlay.classList.remove("show");
          gameOverOverlay.setAttribute("aria-hidden", "true");
        }
      }

      function startGame(){
        if (state.playing) return;
        state.playing = true;
        startOverlay.classList.remove("show");
        // primer gesto habilita audio
        audioEnabled = audioEnabled || (btnSound.getAttribute("aria-pressed") === "true");
        if (audioEnabled){
          playFx("levelup");
          musicStart(() => state.level);
        }
      }

      /* ---------------------------------------------------------
       *  INPUT
       * --------------------------------------------------------- */
      let vibrationOn = true;

      function doJump() {
        if (!state.playing) startGame();
        if (!state.playing) return;
        if (player.jumps >= MAX_JUMPS) return;

        player.vy = -JUMP_FORCE;
        player.jumps++;
        if (audioEnabled) playFx("jump");
        vibrate(10);

        emitParticles(player.x + player.w * 0.45, player.y + player.h, 10, {
          minVx: -1.8, maxVx: 1.8,
          minVy: -2.6, maxVy: -0.7,
          minR: 1.0, maxR: 2.6,
          life: 26,
          gravity: 0.10,
          color: "rgba(56,189,248,0.92)"
        });
      }

      // Activar sonido requiere gesto: usamos el overlay Start como gesto real
      function enableAudio(){
        audioEnabled = true;
        btnSound.setAttribute("aria-pressed", "true");
        btnSound.textContent = "üîä Sonido";
        // Despierta AudioContext
        const ac = getFxCtx();
        if (ac && ac.state === "suspended") ac.resume();
      }

      btnSound.addEventListener("click", () => {
        const on = btnSound.getAttribute("aria-pressed") === "true";
        if (on){
          btnSound.setAttribute("aria-pressed", "false");
          btnSound.textContent = "üîá Silencio";
          audioEnabled = false;
          musicStop();
        } else {
          enableAudio();
          btnSound.setAttribute("aria-pressed", "true");
          btnSound.textContent = "üîä Sonido";
          if (state.playing) musicStart(() => state.level);
          playFx("coin");
        }
      });

      btnVibrate.addEventListener("click", () => {
        vibrationOn = !vibrationOn;
        btnVibrate.setAttribute("aria-pressed", vibrationOn ? "true" : "false");
        btnVibrate.textContent = vibrationOn ? "üì≥ Vibraci√≥n" : "üì¥ Sin vibraci√≥n";
        if (vibrationOn) vibrate(20);
      });

      btnStartTop.addEventListener("click", () => {
        // es un gesto: habilita audio si estaba en ON
        if (btnSound.getAttribute("aria-pressed") === "true") enableAudio();
        startGame();
      });

      btnStart.addEventListener("click", () => {
        if (btnSound.getAttribute("aria-pressed") === "true") enableAudio();
        startGame();
      });

      document.addEventListener("keydown", (e) => {
        if (e.code === "Space" || e.code === "ArrowUp") {
          e.preventDefault();
          doJump();
        }
        if (!state.playing && (e.code === "Enter" || e.code === "KeyR")) {
          resetGame(false);
          startGame();
        }
        if (gameOverOverlay.classList.contains("show") && (e.code === "Enter" || e.code === "KeyR")) {
          restartFromGameOver();
        }
      });

      canvas.addEventListener("click", () => doJump());
      canvas.addEventListener("touchstart", (e) => {
        e.preventDefault();
        doJump();
      }, { passive: false });

      function restartFromGameOver(){
        gameOverOverlay.classList.remove("show");
        gameOverOverlay.setAttribute("aria-hidden", "true");
        resetGame(false);
        startGame();
      }

      btnRestart.addEventListener("click", restartFromGameOver);
      btnRestart2.addEventListener("click", restartFromGameOver);

      // Share: usa Web Share API si existe, si no, copia al portapapeles
      btnShare.addEventListener("click", async () => {
        const text = `Mis monedas en Mundo de Monedas ¬∑ Turbo: ${state.coins} ¬∑ R√©cord: ${bestCoins}`;
        try{
          if (navigator.share){
            await navigator.share({ title: "Mundo de Monedas ¬∑ Turbo", text });
          } else if (navigator.clipboard){
            await navigator.clipboard.writeText(text);
            goTitle.textContent = "Copiado";
            setTimeout(() => (goTitle.textContent = "Fin de partida"), 900);
          }
        } catch(_){}
      });

      // Primer interacci√≥n global: habilitar audio si el usuario ya lo marc√≥ ON y mejorar fullscreen en Android
      let userInteracted = false;

      const markInteraction = () => {
        // Primer gesto: habilita audio si el usuario ya lo marc√≥ ON
        if (!userInteracted){
          userInteracted = true;
          if (btnSound.getAttribute("aria-pressed") === "true") enableAudio();
        }

        // Fullscreen: si el usuario est√° en horizontal (Android/Chrome), el primer toque tras girar dispara fullscreen
        if (awaitingLandscapeTap){
          awaitingLandscapeTap = false;
          requestFullscreenAuto().then(() => setTimeout(applyFit, 60));
        } else {
          // si ya est√° en horizontal y no se intent√≥ a√∫n, intenta autom√°tico
          maybeAutoFullscreen();
        }
      };

      window.addEventListener("pointerdown", markInteraction, { passive:true });
      window.addEventListener("touchstart", markInteraction, { passive:true });
      window.addEventListener("keydown", markInteraction, { passive:true });

      async function requestFullscreenAuto() {
        if (document.fullscreenElement) return true;
        const el = document.getElementById("app");
        if (!el || !el.requestFullscreen) return false;
        try { await el.requestFullscreen(); return true; } catch(e){ return false; }
      }
      let fsAttempted = false;
      async function maybeAutoFullscreen() {
        const vw = window.innerWidth, vh = window.innerHeight;
        const isMobile = Math.min(window.innerWidth, window.innerHeight) <= 900;
        const isLandscape = vw > vh;
        if (!isMobile || !isLandscape) return;
        if (isIOS()) return; // iOS limita fullscreen
        if (!userInteracted) return;
        if (fsAttempted) return;
        fsAttempted = true;
        await requestFullscreenAuto();
        setTimeout(applyFit, 60);
      }

      /* ---------------------------------------------------------
       *  UPDATE WORLD LAYERS
       * --------------------------------------------------------- */
      function updateWorldLayers() {
        for (const s of layers.stars) {
          s.a = clamp(s.a + (Math.random() - 0.5) * s.tw, 0.18, 0.95);
        }

        for (const c of layers.clouds) {
          c.x -= state.speed * c.s;
          if (c.x + c.w < -40) {
            c.x = W + rand(30, 120);
            c.y = rand(16, 110);
            c.w = rand(80, 160);
            c.h = rand(24, 48);
            c.s = rand(0.08, 0.18);
          }
        }

        const moveLayer = (arr, k, yBase, yVar, hBase, hVar, w) => {
          for (const h of arr) {
            h.x -= state.speed * k;
            if (h.x + h.w < 0) {
              h.x = W;
              h.y = yBase - Math.random() * yVar;
              h.h = hBase + Math.random() * hVar;
              h.w = w;
            }
          }
        };

        moveLayer(layers.hillsFar, 0.18, groundY - 92, 46, 116, 58, 260);
        moveLayer(layers.hillsMid, 0.30, groundY - 66, 36, 88, 46, 290);
        moveLayer(layers.hillsNear, 0.48, groundY - 46, 30, 74, 42, 330);
      }

      /* ---------------------------------------------------------
       *  ENTITIES / PHYSICS
       * --------------------------------------------------------- */
      function updatePlayer() {
        if (!state.playing) return;

        player.vy += GRAVITY;
        player.y += player.vy;

        const onGround = (player.y + player.h) >= groundY;
        if (onGround) {
          if (player.vy > 6) {
            emitParticles(player.x + player.w * 0.45, groundY + 1, 12, {
              minVx: -1.8, maxVx: 1.8,
              minVy: -2.4, maxVy: -0.9,
              minR: 1.2, maxR: 2.8,
              life: 22,
              gravity: 0.12,
              color: "rgba(250,204,21,0.92)"
            });
          }
          player.y = groundY - player.h;
          player.vy = 0;
          player.jumps = 0;
        }

        player.bob = lerp(player.bob, onGround ? 0 : 1, 0.10);
      }

      function updateEntities() {
        // spawn cadence (m√°s intenso con el nivel)
        const coinEvery = dynamicSpawnEvery(SPAWN.coinEvery, 40, state.level);
        const blockEvery = dynamicSpawnEvery(SPAWN.blockEvery, 64, state.level);

        if (state.frame % coinEvery === 0) spawnCoin();
        if (state.frame % blockEvery === 0) spawnBlock();

        // powerup raro
        if (state.frame % POWERUP_EVERY === 0 && Math.random() < POWERUP_CHANCE) spawnShield();

        // coins
        for (let i = coins.length - 1; i >= 0; i--) {
          const c = coins[i];
          c.x -= state.speed;
          c.spin += 0.11;
          if (c.x < -40) coins.splice(i, 1);
        }

        // blocks
        for (let i = blocks.length - 1; i >= 0; i--) {
          const b = blocks[i];
          b.x -= state.speed;
          if (b.x < -120) blocks.splice(i, 1);
        }

        // powerups
        for (let i = powerups.length - 1; i >= 0; i--){
          const p = powerups[i];
          p.x -= state.speed;
          p.spin += 0.10;
          if (p.x < -80) powerups.splice(i, 1);
        }
      }

      function circleHit(px, py, pr, bx, by, bw, bh) {
        const cx = clamp(px, bx, bx + bw);
        const cy = clamp(py, by, by + bh);
        const dx = px - cx;
        const dy = py - cy;
        return (dx * dx + dy * dy) <= pr * pr;
      }

      function checkCoinCollisions() {
        const px = player.x + player.w * 0.5;
        const py = player.y + player.h * 0.5;

        for (const c of coins) {
          if (c.collected) continue;

          const hit = circleHit(px, py, 14, c.x - c.r, c.y - c.r, c.r * 2, c.r * 2);
          if (!hit) continue;

          c.collected = true;
          state.coins++;

          bumpCombo();
          state.score += Math.floor(SCORE_PER_COIN * state.multiplier);

          if (hudCoins) hudCoins.textContent = String(state.coins);

          // r√©cord por monedas (competencia centrada en monedas)
          if (state.coins > bestCoins){
            bestCoins = state.coins;
            setBestCoins(bestCoins);
            if (hudBestCoins) hudBestCoins.textContent = String(bestCoins);
          }
emitParticles(c.x, c.y, 18, {
            minVx: -2.6, maxVx: 2.6,
            minVy: -3.2, maxVy: -1.0,
            minR: 1.0, maxR: 3.2,
            life: 30,
            gravity: 0.09,
            color: "rgba(250,204,21,0.96)"
          });

          vibrate(8);

          // nivel (se recalcula centralmente)
          updateLevelFromScore();
        }
      }

      function checkPowerupCollisions(){
        const px = player.x + player.w * 0.5;
        const py = player.y + player.h * 0.5;

        for (let i = powerups.length - 1; i >= 0; i--){
          const p = powerups[i];
          const hit = circleHit(px, py, 15, p.x - p.r, p.y - p.r, p.r * 2, p.r * 2);
          if (!hit) continue;

          powerups.splice(i, 1);
          if (p.type === "shield"){
            state.shield = SHIELD_DURATION_FRAMES;
            playFx("power");
            emitParticles(px, py, 22, {
              minVx: -2.8, maxVx: 2.8,
              minVy: -3.0, maxVy: -0.6,
              minR: 1.0, maxR: 3.0,
              life: 34,
              gravity: 0.08,
              color: "rgba(56,189,248,0.92)"
            });
            vibrate(14);
          }
        }
      }

      function endGame(reason = "hit") {
        state.playing = false;
        const sInt = Math.floor(state.score);
        btnRestart.style.display = "inline-flex";

        // feedback fuerte
        state.shake = 18;
        playFx("hit");
        playFx("lose");
        musicStop();
        vibrate(80);

        // r√©cord por monedas
        if (state.coins > bestCoins){
          bestCoins = state.coins;
          setBestCoins(bestCoins);
          if (hudBestCoins) hudBestCoins.textContent = String(bestCoins);
        }

        // overlay stats (enfocado en monedas)
        goTitle.textContent = (state.coins >= bestCoins) ? "Nuevo r√©cord" : "Fin de partida";
        goStats.innerHTML = `Monedas: <b>${state.coins}</b> ¬∑ R√©cord: <b>${bestCoins}</b>`;
gameOverOverlay.classList.add("show");
        gameOverOverlay.setAttribute("aria-hidden", "false");
      }

      function checkBlockCollisions() {
        for (const b of blocks) {
          const hit =
            player.x < b.x + b.w &&
            player.x + player.w > b.x &&
            player.y < b.y + b.h &&
            player.y + player.h > b.y;

          if (!hit) continue;

          if (state.shield > 0){
            // Consume shield, push player a bit back and continue
            state.shield = 0;
            state.shake = 10;
            playFx("shieldBreak");
            emitParticles(player.x + player.w*0.5, player.y + player.h*0.6, 26, {
              minVx: -3.2, maxVx: 3.2,
              minVy: -3.2, maxVy: -0.6,
              minR: 1.0, maxR: 3.4,
              life: 38,
              gravity: 0.10,
              color: "rgba(167,139,250,0.92)"
            });
            // penaliza combo
            setCombo(1);
            state.comboT = 0;
            // leve ‚Äúknock‚Äù
            player.vy = -10;
            vibrate(40);
            return;
          }

          // sin shield: termina
          emitParticles(player.x + player.w * 0.55, player.y + player.h * 0.55, 30, {
            minVx: -3.2, maxVx: 3.2,
            minVy: -3.2, maxVy: -0.6,
            minR: 1.2, maxR: 3.6,
            life: 42,
            gravity: 0.10,
            color: "rgba(251,113,133,0.92)"
          });

          endGame("hit");
          break;
        }
      }

      function updateScoreDistance(){
        // suma por distancia, escalado con speed y multiplicador (siente competitivo)
        const add = (BASE_DISTANCE_RATE * state.speed) * state.multiplier;
        state.distance += state.speed;
        state.score += add;
        // puntaje interno (UI enfocada en monedas)
}

      function updateTimers(){
        if (state.shield > 0) state.shield--;
        decayCombo();
      }

      /* ---------------------------------------------------------
       *  UPDATE LOOP
       * --------------------------------------------------------- */
      function update() {
        state.frame++;

        if (state.shake > 0) state.shake--;

        updateWorldLayers();
        updateParticles();

        if (!state.playing) return;

        updatePlayer();
        updateEntities();
        updateScoreDistance();
        updateLevelFromScore();
        updateTimers();

        checkCoinCollisions();
        checkPowerupCollisions();
        checkBlockCollisions();

        if (state.banner > 0) state.banner--;
      }

      /* ---------------------------------------------------------
       *  DRAW (impactante + competitivo)
       * --------------------------------------------------------- */
      function applyShake() {
        if (state.shake <= 0) return { x: 0, y: 0 };
        const power = state.shake / 18;
        return {
          x: (Math.random() - 0.5) * 10 * power,
          y: (Math.random() - 0.5) * 6 * power
        };
      }

      function drawSky() {
        const grad = ctx.createLinearGradient(0, 0, 0, H);
        grad.addColorStop(0, "#7cc3ff");
        grad.addColorStop(0.52, "#1d4ed8");
        grad.addColorStop(1, "#070b18");
        ctx.fillStyle = grad;
        ctx.fillRect(0, 0, W, H);

        // auroras / ne√≥n suave
        const a1 = ctx.createRadialGradient(W*0.22, H*0.22, 30, W*0.22, H*0.22, 420);
        a1.addColorStop(0, "rgba(56,189,248,0.20)");
        a1.addColorStop(1, "rgba(56,189,248,0.00)");
        ctx.fillStyle = a1; ctx.fillRect(0,0,W,H);

        const a2 = ctx.createRadialGradient(W*0.82, H*0.28, 30, W*0.82, H*0.28, 440);
        a2.addColorStop(0, "rgba(167,139,250,0.18)");
        a2.addColorStop(1, "rgba(167,139,250,0.00)");
        ctx.fillStyle = a2; ctx.fillRect(0,0,W,H);

        // vignette
        const v = ctx.createRadialGradient(W * 0.5, H * 0.45, 60, W * 0.5, H * 0.5, 560);
        v.addColorStop(0, "rgba(255,255,255,0.06)");
        v.addColorStop(1, "rgba(0,0,0,0.24)");
        ctx.fillStyle = v;
        ctx.fillRect(0, 0, W, H);
      }

      function drawStars() {
        for (const s of layers.stars) {
          ctx.globalAlpha = s.a;
          ctx.beginPath();
          ctx.arc(s.x, s.y, s.r, 0, Math.PI * 2);
          ctx.fillStyle = "#e2e8f0";
          ctx.fill();
        }
        ctx.globalAlpha = 1;
      }

      function drawClouds() {
        for (const c of layers.clouds) {
          ctx.globalAlpha = 0.18;
          ctx.fillStyle = "#e2e8f0";
          ctx.beginPath();
          ctx.ellipse(c.x, c.y, c.w * 0.42, c.h * 0.50, 0, 0, Math.PI * 2);
          ctx.ellipse(c.x + c.w * 0.18, c.y - c.h * 0.20, c.w * 0.36, c.h * 0.46, 0, 0, Math.PI * 2);
          ctx.ellipse(c.x - c.w * 0.18, c.y - c.h * 0.10, c.w * 0.32, c.h * 0.40, 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalAlpha = 1;
        }
      }

      function drawHills(arr, fillA, fillB) {
        const g = ctx.createLinearGradient(0, groundY - 140, 0, groundY + 20);
        g.addColorStop(0, fillA);
        g.addColorStop(1, fillB);
        ctx.fillStyle = g;

        for (const h of arr) {
          ctx.beginPath();
          ctx.moveTo(h.x, groundY);
          ctx.quadraticCurveTo(h.x + h.w * 0.5, h.y, h.x + h.w, groundY);
          ctx.closePath();
          ctx.fill();
        }
      }

      function drawGround() {
        const g = ctx.createLinearGradient(0, groundY, 0, H);
        g.addColorStop(0, "#f7c96a");
        g.addColorStop(1, "#9a3412");
        ctx.fillStyle = g;
        ctx.fillRect(0, groundY, W, H - groundY);

        // top edge
        ctx.fillStyle = "rgba(15,23,42,0.20)";
        ctx.fillRect(0, groundY, W, 6);

        // texture
        ctx.globalAlpha = 0.18;
        ctx.fillStyle = "#7c2d12";
        for (let i = 0; i < 70; i++) {
          const x = (i * 19 + (state.frame * 2)) % W;
          const y = groundY + 10 + (i % 4) * 8;
          ctx.beginPath();
          ctx.arc(x, y, 1.1, 0, Math.PI * 2);
          ctx.fill();
        }
        ctx.globalAlpha = 1;
      }

      
      function drawPlayer() {
        // Animaci√≥n: squash/stretch seg√∫n velocidad vertical
        const x = player.x;
        const y = player.y;
        const w = player.w;
        const h = player.h;

        const vy = player.vy;
        const t = state.frame * 0.12;

        const squash = clamp(1 + (vy * 0.010), 0.86, 1.14);
        const stretch = clamp(1 - (vy * 0.010), 0.86, 1.22);

        // Shadow
        ctx.fillStyle = "rgba(15,23,42,0.38)";
        ctx.beginPath();
        ctx.ellipse(x + w * 0.52, groundY + 6, (w * 0.78) * stretch, 6.8, 0, 0, Math.PI * 2);
        ctx.fill();

        // Trail glow (cuando est√° en el aire)
        if (player.y + player.h < groundY - 2) {
          const glow = ctx.createRadialGradient(x + w * 0.40, y + h * 0.70, 4, x + w * 0.20, y + h * 0.70, 44);
          glow.addColorStop(0, "rgba(56,189,248,0.20)");
          glow.addColorStop(0.55, "rgba(167,139,250,0.16)");
          glow.addColorStop(1, "rgba(56,189,248,0.00)");
          ctx.fillStyle = glow;
          ctx.beginPath();
          ctx.arc(x + w * 0.35, y + h * 0.70, 44, 0, Math.PI * 2);
          ctx.fill();
        }

        // ‚ÄúRunner‚Äù futurista: casco + cuerpo + botas
        ctx.save();
        ctx.translate(x + w * 0.5, y + h * 0.5);
        ctx.scale(stretch, squash);
        ctx.translate(-(x + w * 0.5), -(y + h * 0.5));

        // Body gradient (ne√≥n premium)
        const body = ctx.createLinearGradient(x, y, x + w, y + h);
        body.addColorStop(0, "#38bdf8");
        body.addColorStop(0.55, "#a78bfa");
        body.addColorStop(1, "#22c55e");

        // Main body
        roundedRectPath(ctx, x, y + 6, w, h - 6, 11);
        ctx.fillStyle = body;
        ctx.fill();

        // Helmet (top cap)
        const helmet = ctx.createLinearGradient(x, y, x, y + 18);
        helmet.addColorStop(0, "rgba(248,250,252,0.35)");
        helmet.addColorStop(1, "rgba(15,23,42,0.15)");
        roundedRectPath(ctx, x + 2, y + 2, w - 4, 18, 10);
        ctx.fillStyle = helmet;
        ctx.fill();

        // Visor
        const visor = ctx.createLinearGradient(x, y, x + w, y);
        visor.addColorStop(0, "rgba(236,254,255,0.95)");
        visor.addColorStop(1, "rgba(203,213,245,0.70)");
        roundedRectPath(ctx, x + 5, y + 9, w - 10, 12, 7);
        ctx.fillStyle = visor;
        ctx.fill();

        // ‚ÄúEyes‚Äù sparkle
        ctx.fillStyle = "rgba(11,18,36,0.88)";
        ctx.beginPath();
        ctx.arc(x + w * 0.38, y + 15, 2.15, 0, Math.PI * 2);
        ctx.arc(x + w * 0.64, y + 15, 2.15, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "rgba(255,255,255,0.75)";
        ctx.beginPath();
        ctx.arc(x + w * 0.40, y + 14, 0.9, 0, Math.PI * 2);
        ctx.arc(x + w * 0.66, y + 14, 0.9, 0, Math.PI * 2);
        ctx.fill();

        // Chest ‚Äúcoin‚Äù emblem
        const cx = x + w * 0.52;
        const cy = y + h * 0.60;
        const rr = 5.6 + 0.9 * Math.sin(t);
        const emblem = ctx.createRadialGradient(cx, cy, 1, cx, cy, rr + 6);
        emblem.addColorStop(0, "rgba(250,204,21,0.95)");
        emblem.addColorStop(0.55, "rgba(250,204,21,0.55)");
        emblem.addColorStop(1, "rgba(250,204,21,0.00)");
        ctx.fillStyle = emblem;
        ctx.beginPath();
        ctx.arc(cx, cy, rr + 6, 0, Math.PI * 2);
        ctx.fill();
        ctx.fillStyle = "rgba(250,204,21,0.90)";
        ctx.beginPath();
        ctx.arc(cx, cy, rr, 0, Math.PI * 2);
        ctx.fill();

        // Belt
        ctx.fillStyle = "rgba(2,6,23,0.35)";
        roundedRectPath(ctx, x + 4, y + 27, w - 8, 6, 5);
        ctx.fill();
        const beltGlow = ctx.createLinearGradient(x, y, x + w, y);
        beltGlow.addColorStop(0, "rgba(56,189,248,0.95)");
        beltGlow.addColorStop(1, "rgba(167,139,250,0.95)");
        ctx.fillStyle = beltGlow;
        roundedRectPath(ctx, x + 6, y + 28.3, w - 12, 3.4, 4);
        ctx.fill();

        // Boots
        ctx.fillStyle = "rgba(11,18,36,0.82)";
        roundedRectPath(ctx, x + 4, y + h - 6, w * 0.40, 7.5, 5);
        ctx.fill();
        roundedRectPath(ctx, x + w * 0.56, y + h - 6, w * 0.40, 7.5, 5);
        ctx.fill();
        ctx.fillStyle = "rgba(56,189,248,0.65)";
        roundedRectPath(ctx, x + 6, y + h - 4.8, w * 0.36, 2.4, 3);
        ctx.fill();
        roundedRectPath(ctx, x + w * 0.58, y + h - 4.8, w * 0.36, 2.4, 3);
        ctx.fill();

        // Outline
        ctx.strokeStyle = "rgba(15,23,42,0.46)";
        ctx.lineWidth = 1.2;
        roundedRectPath(ctx, x + 0.6, y + 6.6, w - 1.2, h - 7.2, 11);
        ctx.stroke();

        
        // Neon outline pulse
        ctx.globalAlpha = 0.85;
        ctx.strokeStyle = `rgba(56,189,248,${0.45 + 0.25*Math.sin(t*0.9)})`;
        ctx.lineWidth = 1.6;
        roundedRectPath(ctx, x + 0.6, y + 6.6, w - 1.2, (h - 6) - 1.2, 11);
        ctx.stroke();
        ctx.globalAlpha = 1;

        // Visor glow pulse
        ctx.save();
        ctx.globalAlpha = 0.9;
        const vg = ctx.createRadialGradient(x + w*0.72, y + 18, 2, x + w*0.62, y + 18, 18);
        vg.addColorStop(0, `rgba(56,189,248,${0.55 + 0.25*Math.sin(t)})`);
        vg.addColorStop(1, "rgba(56,189,248,0)");
        ctx.fillStyle = vg;
        ctx.beginPath();
        ctx.arc(x + w*0.65, y + 18, 18, 0, Math.PI*2);
        ctx.fill();
        ctx.restore();

        ctx.restore();

        // Shield aura
        if (state.shield > 0){
          const tt = (state.shield / SHIELD_DURATION_FRAMES);
          const aura = ctx.createRadialGradient(x+w*0.5, y+h*0.55, 6, x+w*0.5, y+h*0.55, 34);
          aura.addColorStop(0, `rgba(56,189,248,${0.14 + 0.10*(1-tt)})`);
          aura.addColorStop(0.55, `rgba(167,139,250,${0.12 + 0.10*(1-tt)})`);
          aura.addColorStop(1, "rgba(56,189,248,0.00)");
          ctx.fillStyle = aura;
          ctx.beginPath();
          ctx.arc(x+w*0.5, y+h*0.55, 34, 0, Math.PI*2);
          ctx.fill();

          ctx.strokeStyle = "rgba(56,189,248,0.60)";
          ctx.lineWidth = 2;
          ctx.beginPath();
          ctx.arc(x+w*0.5, y+h*0.55, 24, 0, Math.PI*2);
          ctx.stroke();
        }
      }

      function drawCoins() {
        for (const c of coins) {
          if (c.collected) continue;

          const scale = 0.66 + 0.34 * Math.abs(Math.sin(c.spin));
          const rx = c.r * scale;
          const ry = c.r;

          ctx.save();
          ctx.translate(c.x, c.y);

          // glow
          ctx.globalAlpha = 0.26 + c.glow * 0.28;
          ctx.beginPath();
          ctx.ellipse(0, 0, rx + 10, ry + 10, 0, 0, Math.PI * 2);
          ctx.fillStyle = "rgba(250,204,21,0.95)";
          ctx.fill();
          ctx.globalAlpha = 1;

          const grad = ctx.createRadialGradient(-4, -4, 2, 0, 0, ry + 6);
          grad.addColorStop(0, "#fff7c2");
          grad.addColorStop(0.45, "#fde047");
          grad.addColorStop(1, "#a16207");

          ctx.fillStyle = grad;
          ctx.beginPath();
          ctx.ellipse(0, 0, rx, ry, 0, 0, Math.PI * 2);
          ctx.fill();

          ctx.strokeStyle = "rgba(0,0,0,0.22)";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.ellipse(0, 0, rx - 2.6, ry - 2.6, 0, 0, Math.PI * 2);
          ctx.stroke();

          ctx.fillStyle = "#78350f";
          ctx.font = "12px system-ui";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText("‚òÖ", 0, 1);

          ctx.restore();
        }
      }

      function drawPowerups(){
        for (const p of powerups){
          ctx.save();
          ctx.translate(p.x, p.y);

          const scale = 0.70 + 0.30*Math.abs(Math.sin(p.spin));
          const r = p.r;

          // glow
          ctx.globalAlpha = 0.28;
          ctx.beginPath();
          ctx.arc(0, 0, r + 10, 0, Math.PI*2);
          ctx.fillStyle = "rgba(56,189,248,0.95)";
          ctx.fill();
          ctx.globalAlpha = 1;

          const g = ctx.createRadialGradient(-4,-4,2,0,0,r+7);
          g.addColorStop(0, "rgba(255,255,255,0.90)");
          g.addColorStop(0.40, "rgba(56,189,248,0.95)");
          g.addColorStop(1, "rgba(30,64,175,0.95)");

          ctx.fillStyle = g;
          ctx.beginPath();
          ctx.arc(0,0,r*scale,0,Math.PI*2);
          ctx.fill();

          ctx.strokeStyle = "rgba(15,23,42,0.40)";
          ctx.lineWidth = 1.2;
          ctx.beginPath();
          ctx.arc(0,0,r*scale,0,Math.PI*2);
          ctx.stroke();

          ctx.fillStyle = "rgba(255,255,255,0.95)";
          ctx.font = "900 12px system-ui";
          ctx.textAlign = "center";
          ctx.textBaseline = "middle";
          ctx.fillText("‚õ®", 0, 1);

          ctx.restore();
        }
      }

      function drawBlocks() {
        for (const b of blocks) {
          const g = ctx.createLinearGradient(b.x, b.y, b.x, b.y + b.h);
          g.addColorStop(0, "rgba(251,113,133,0.98)");
          g.addColorStop(1, "rgba(127,29,29,0.98)");
          ctx.fillStyle = g;
          ctx.fillRect(b.x, b.y, b.w, b.h);

          // top shine
          ctx.fillStyle = "rgba(254,242,242,0.55)";
          ctx.fillRect(b.x, b.y, b.w, 4);

          // side shade
          ctx.fillStyle = "rgba(0,0,0,0.18)";
          ctx.fillRect(b.x + b.w - 5, b.y, 5, b.h);

          // warning stripe (competitivo)
          if (b.kind === "tall"){
            ctx.globalAlpha = 0.35;
            ctx.fillStyle = "rgba(250,204,21,0.95)";
            for (let y = b.y + 6; y < b.y + b.h; y += 14){
              ctx.fillRect(b.x + 3, y, b.w - 6, 6);
            }
            ctx.globalAlpha = 1;
          }

          ctx.strokeStyle = "rgba(0,0,0,0.32)";
          ctx.lineWidth = 1;
          ctx.strokeRect(b.x + 0.5, b.y + 0.5, b.w - 1, b.h - 1);
        }
      }

      function drawLevelBanner() {
        if (state.banner <= 0) return;

        const alpha = Math.min(1, state.banner / 40);
        const w = 300, h = 64;
        const x = (W - w) / 2;
        const y = 48;

        ctx.save();
        ctx.globalAlpha = alpha;

        ctx.fillStyle = "rgba(15,23,42,0.88)";
        roundedRectPath(ctx, x, y, w, h, 14);
        ctx.fill();

        ctx.shadowColor = "rgba(56,189,248,0.55)";
        ctx.shadowBlur = 14;
        ctx.strokeStyle = "rgba(56,189,248,0.92)";
        ctx.lineWidth = 2;
        roundedRectPath(ctx, x + 0.5, y + 0.5, w - 1, h - 1, 14);
        ctx.stroke();

        ctx.shadowBlur = 0;
        ctx.fillStyle = "#f9fafb";
        ctx.font = "1000 22px system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText("Nivel " + state.level, W / 2, y + h / 2);

        ctx.restore();
      }

      function drawComboToast(){
        if (!state.playing) return;
        if (state.combo < 3) return;

        const t = state.comboT / COMBO_WINDOW_FRAMES;
        const alpha = clamp(0.18 + (1 - t) * 0.65, 0, 0.9);

        ctx.save();
        ctx.globalAlpha = alpha;

        const txt = "COMBO x" + state.multiplier;
        ctx.font = "1000 18px system-ui";
        const m = ctx.measureText(txt);

        const w = m.width + 26;
        const h = 38;
        const x = 18;
        const y = 18;

        ctx.fillStyle = "rgba(15,23,42,0.72)";
        roundedRectPath(ctx, x, y, w, h, 12);
        ctx.fill();

        ctx.strokeStyle = "rgba(250,204,21,0.65)";
        ctx.lineWidth = 1.5;
        roundedRectPath(ctx, x + 0.5, y + 0.5, w - 1, h - 1, 12);
        ctx.stroke();

        ctx.fillStyle = "rgba(250,204,21,0.95)";
        ctx.textAlign = "left";
        ctx.textBaseline = "middle";
        ctx.fillText(txt, x + 13, y + h / 2);

        ctx.restore();
      }

      function draw() {
        const shake = applyShake();

        ctx.save();
        ctx.clearRect(0, 0, W, H);
        ctx.translate(shake.x, shake.y);

        drawSky();
        drawStars();
        drawClouds();

        drawHills(layers.hillsFar, "rgba(30,58,138,0.90)", "rgba(2,6,23,0.10)");
        drawHills(layers.hillsMid, "rgba(29,78,216,0.92)", "rgba(2,6,23,0.16)");
        drawHills(layers.hillsNear, "rgba(37,99,235,0.96)", "rgba(2,6,23,0.20)");

        drawGround();

        drawCoins();
        drawPowerups();
        drawBlocks();
        drawParticles();
        drawPlayer();
        drawLevelBanner();
        drawComboToast();

        // si no est√° jugando, muestra ‚Äúghost‚Äù de pause sin tapar overlays (ya est√°n en DOM)
        if (!state.playing && !startOverlay.classList.contains("show") && !gameOverOverlay.classList.contains("show")){
          ctx.fillStyle = "rgba(2,6,23,0.40)";
          ctx.fillRect(0,0,W,H);
        }

        ctx.restore();
      }

      /* ---------------------------------------------------------
       *  LOOP
       * --------------------------------------------------------- */
      function loop() {
        update();
        draw();
        requestAnimationFrame(loop);
      }

      // Init
      resetGame(false);
      loop();

      // Si el usuario toca el overlay, arranca (mejor UX)
      startOverlay.addEventListener("click", (e) => {
        const target = e.target;
        // no cerrar si fue click en bot√≥n ya manejado
        if (target && target.closest("button")) return;
        startGame();
      });

      // Ajuste al cargar
      setTimeout(applyFit, 60);
    })();
  </script>
</body>
</html>
