<!doctype html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <title>RinoPac ¬∑ Pro</title>
  <style>
    :root{
      --bg0:#05060d;
      --bg1:#0b1020;
      --bg2:#020617;

      --panel: rgba(15, 23, 42, 0.82);
      --panel2: rgba(2, 6, 23, 0.55);
      --stroke: rgba(148, 163, 184, 0.18);

      --text:#f8fafc;
      --muted:#cbd5f5;

      --accent:#38bdf8;
      --accent2:#a78bfa;

      --gold:#facc15;
      --green:#22c55e;
      --red:#fb7185;
      --amber:#f59e0b;
    }

    *{ box-sizing:border-box; margin:0; padding:0;
       font-family: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, "Helvetica Neue", Arial, "Apple Color Emoji","Segoe UI Emoji"; }
    html, body{ height:100%; width:100%; }

    body{
      min-height:100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      color:var(--text);
      padding:16px;
      overflow:hidden;
      touch-action:none;
      -webkit-user-select:none;
      user-select:none;
      background:
        radial-gradient(1100px 520px at 18% 12%, rgba(56,189,248,0.18), transparent 60%),
        radial-gradient(900px 500px at 82% 18%, rgba(167,139,250,0.18), transparent 60%),
        radial-gradient(1000px 600px at 50% 88%, rgba(250,204,21,0.10), transparent 60%),
        linear-gradient(180deg, var(--bg1), var(--bg2));
    }

    #app{ position:relative; width:100%; display:flex; justify-content:center; }

    .game-wrapper{
      width:100%;
      max-width:1200px;
      background: linear-gradient(180deg, var(--panel), rgba(15,23,42,0.68));
      border:1px solid var(--stroke);
      border-radius:26px;
      box-shadow: 0 26px 70px rgba(0,0,0,.48), inset 0 1px 0 rgba(255,255,255,0.06);
      padding:16px 16px 18px;
      display:flex;
      flex-direction:column;
      gap:12px;
      position:relative;
      overflow:hidden;
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    .game-wrapper::before{
      content:"";
      position:absolute;
      inset:-40% -30%;
      background: linear-gradient(120deg, transparent 35%, rgba(255,255,255,0.05) 46%, transparent 58%);
      transform: rotate(10deg);
      pointer-events:none;
    }

    .topbar{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:12px;
      position:relative;
      z-index:2;
      pointer-events:auto;
    }
    .brand{
      display:flex;
      align-items:center;
      gap:10px;
      min-width:0;
      flex:1 1 auto;
    }
    .logo{
      width:40px; height:40px;
      border-radius:14px;
      display:grid;
      place-items:center;
      background:
        radial-gradient(20px 20px at 30% 30%, rgba(255,255,255,0.24), transparent 60%),
        linear-gradient(135deg, rgba(250,204,21,0.95), rgba(56,189,248,0.92));
      box-shadow: 0 10px 22px rgba(0,0,0,0.35);
      border:1px solid rgba(255,255,255,0.18);
      font-weight: 1000;
      user-select:none;
    }
    .brand h1{
      font-size:16px;
      font-weight:1000;
      letter-spacing:.2px;
      margin-bottom:1px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
      max-width: 44vw;
    }
    .brand p{
      font-size:12px;
      color: rgba(203,213,245,0.92);
      line-height:1.25;
      max-width: 640px;
    }

    .actions{
      display:flex;
      align-items:center;
      gap:10px;
      flex-wrap:nowrap;
      justify-content:flex-end;
      overflow-x:auto;
      -webkit-overflow-scrolling:touch;
      scrollbar-width:none;
      max-width: 56vw;
    }
    .actions::-webkit-scrollbar{ display:none; }
    .actions .btn{ flex:0 0 auto; }

    .btn{
      border:none;
      border-radius:14px;
      padding:9px 12px;
      font-size:12px;
      font-weight:1000;
      cursor:pointer;
      color:var(--text);
      background: rgba(255,255,255,0.10);
      border:1px solid rgba(255,255,255,0.14);
      transition:transform .12s ease, filter .12s ease, background .12s ease;
      user-select:none;
      display:inline-flex;
      align-items:center;
      gap:8px;
      backdrop-filter: blur(8px);
      -webkit-backdrop-filter: blur(8px);
      white-space:nowrap;
    }
    .btn:hover{ transform: translateY(-1px); filter: brightness(1.03); background: rgba(255,255,255,0.12); }
    .btn:active{ transform: translateY(1px); }
    .btn-primary{
      background: linear-gradient(135deg, rgba(56,189,248,0.92), rgba(167,139,250,0.92));
      border:1px solid rgba(255,255,255,0.20);
    }
    .btn-danger{
      background: linear-gradient(135deg, rgba(251,113,133,0.92), rgba(245,158,11,0.70));
      border:1px solid rgba(255,255,255,0.18);
    }
    .btn-volver{
      background: rgba(226,232,240,0.90);
      color:#0b1020;
      border:1px solid rgba(255,255,255,0.35);
    }

    .game-container{
      margin-top:6px;
      background:
        radial-gradient(900px 260px at 50% 0%, rgba(56,189,248,0.14), transparent 60%),
        linear-gradient(180deg, rgba(2,6,23,0.60), rgba(2,6,23,0.35));
      border-radius:22px;
      overflow:hidden;
      padding:0;
      box-shadow: inset 0 0 0 1px rgba(15,23,42,.35), 0 20px 40px rgba(0,0,0,0.28);
      display:flex;
      flex-direction:column;
      gap:8px;
      position:relative;
      flex:1;
      min-height: 420px;
    }

    .hud-overlay{
      position:absolute;
      left:12px; right:12px; top:12px;
      display:flex;
      justify-content:space-between;
      align-items:flex-start;
      gap:10px;
      z-index:20;
      pointer-events:none;
    }
    .hud-overlay .left,
    .hud-overlay .right{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      pointer-events:none;
    }
    .chip{
      display:flex;
      align-items:center;
      gap:8px;
      padding:6px 8px;
      border-radius:12px;
      background: rgba(2,6,23,0.45);
      border:1px solid rgba(148,163,184,0.18);
      box-shadow: inset 0 1px 0 rgba(255,255,255,0.05);
      font-size:11px;
      font-weight:900;
      color: rgba(248,250,252,0.95);
      white-space:nowrap;
      user-select:none;
      pointer-events:auto;
    }
    .chip b{ color: var(--gold); }
    .chip .sub{ font-weight:900; color: rgba(203,213,245,0.90); }
    .chip .sub b{ color: rgba(248,250,252,0.95); }

    canvas{
      display:block;
      margin:0 auto;
      width:100%;
      height:100%;
      border-radius:18px;
      background:
        radial-gradient(820px 260px at 50% 10%, rgba(255,255,255,0.08), transparent 60%),
        linear-gradient(180deg, #0b1224, #020617);
      touch-action:none;
      box-shadow: inset 0 0 0 1px rgba(255,255,255,0.06);
    }

    /* Virtual joystick (m√≥vil) */
    .joystick{
      position:absolute;
      left: max(6px, env(safe-area-inset-left));
      bottom: max(12px, env(safe-area-inset-bottom));
      width: 112px;
      height: 112px;
      display:none;
      z-index:35;
      pointer-events:auto;
      touch-action:none;
      -webkit-user-select:none;
      user-select:none;
    }
    .joy-base{
      position:absolute;
      inset:0;
      border-radius:999px;
      background: rgba(255,255,255,0.08);
      border: 1px solid rgba(255,255,255,0.14);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      box-shadow: 0 18px 38px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.10);
    }
    .joy-knob{
      position:absolute;
      width: 52px;
      height: 52px;
      left: 50%;
      top: 50%;
      transform: translate(-50%, -50%);
      border-radius:999px;
      background: rgba(255,255,255,0.14);
      border: 1px solid rgba(255,255,255,0.18);
      box-shadow: 0 14px 26px rgba(0,0,0,0.35), inset 0 1px 0 rgba(255,255,255,0.10);
    }

    /* Overlays */
    .overlay{
      position:absolute;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      padding:24px;
      z-index:50;
      background: rgba(0,0,0,0.70);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
    }
    .overlay.show{ display:flex; }
    #rotateHint{ z-index: 70; }

    .card{
      width:min(560px, 94vw);
      border-radius:24px;
      padding:18px 18px 16px;
      background: rgba(15,23,42,0.92);
      border:1px solid rgba(56,189,248,0.26);
      box-shadow: 0 22px 60px rgba(0,0,0,0.55);
      text-align:left;
      display:flex;
      gap:14px;
      align-items:flex-start;
    }
    .card .icon{
      width:56px;
      height:56px;
      border-radius:18px;
      display:grid;
      place-items:center;
      flex: 0 0 auto;
      background: radial-gradient(20px 20px at 30% 30%, rgba(255,255,255,0.22), transparent 60%),
                  linear-gradient(135deg, rgba(56,189,248,0.95), rgba(167,139,250,0.95));
      border:1px solid rgba(255,255,255,0.16);
      font-size:24px;
    }
    .card h2{
      font-size:18px;
      font-weight:1100;
      letter-spacing:.2px;
      margin-bottom:6px;
    }
    .card p{
      font-size:13px;
      font-weight:700;
      color: rgba(203,213,245,0.92);
      line-height:1.35;
      margin-bottom:10px;
    }
    .card .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
    .card .mini{ font-size:12px; color: rgba(203,213,245,0.88); line-height:1.35; margin-top:8px; }

    /* iOS Hint (banner superior) */
    #iosHint{
      position:absolute;
      left:12px; right:12px; top:12px;
      z-index:80;
      display:none;
      padding:10px 12px;
      border-radius:16px;
      background:rgba(15,23,42,0.92);
      border:1px solid rgba(56,189,248,0.24);
      color:#f9fafb;
      font:800 12px/1.25 system-ui, -apple-system, Segoe UI, Roboto, Arial;
      box-shadow:0 14px 30px rgba(0,0,0,0.35);
    }
    #iosHint .row{ display:flex; align-items:flex-start; gap:10px; }
    #iosHint .ttl{ font-size:13px; font-weight:1100; margin-bottom:2px; }
    #iosHint .mut{ color:rgba(203,213,245,0.92); font-weight:750; }
    #iosHint .x{
      margin-left:auto;
      border:0;
      background:rgba(255,255,255,0.10);
      color:#fff;
      border-radius:10px;
      padding:6px 8px;
      font:1000 12px system-ui;
      cursor:pointer;
      flex:0 0 auto;
    }

    /* Mobile: full screen app */
    @media (max-width: 820px){
      body{ padding:0; align-items:stretch; justify-content:stretch; }
      #app{ position:fixed; inset:0;
            padding: env(safe-area-inset-top) env(safe-area-inset-right) env(safe-area-inset-bottom) env(safe-area-inset-left); }
      .game-wrapper{ max-width:none; width:100%; height:100%; border-radius:0; box-shadow:none; padding:12px; border-left:0; border-right:0; }
      .brand p{ display:none; }
      .game-container{ flex:1; min-height:0; }
      .joystick{ display:block; }
    }
    @media (max-width: 420px){
      .card{ flex-direction:column; text-align:center; align-items:center; }
      .card .row{ justify-content:center; }
    }
    body.mobile-land .topbar{
      position:absolute; left:12px; right:12px; top:12px;
      z-index:30; pointer-events:none;
    }
    body.mobile-land .topbar .actions,
    body.mobile-land .topbar .btn,
    body.mobile-land .topbar .chip{ pointer-events:auto; }
    body.mobile-land .game-wrapper{ padding-top:84px; }

    body.fs{ padding:0 !important; overflow:hidden; }
    body.fs #app{ padding:0 !important; }
    body.fs .game-wrapper{ border-radius:0 !important; box-shadow:none !important; border:0 !important; padding:0 !important; height:100% !important; }
    body.fs .game-container{ border-radius:0 !important; box-shadow:none !important; }
    body.fs .topbar{ position:absolute; left:12px; right:12px; top:12px; z-index:30; pointer-events:none; }
    body.fs .topbar .actions, body.fs .topbar .btn{ pointer-events:auto; }
    body.fs .hud-overlay{ top:56px; }
  </style>
</head>
<body>
  <div id="app">
    <div class="game-wrapper">
      <div class="topbar">
        <div class="brand">
          <div class="logo" aria-hidden="true">üü°</div>
          <div>
            <h1>RinoZone ¬∑ RinoPac</h1>
            <p id="hello">Jugador</p>
          </div>
        </div>
        <div class="actions">
          <button class="btn btn-volver" id="btnBack" type="button">‚¨Ö Volver</button>
          <button class="btn btn-primary" id="btnStartTop" type="button">‚ñ∂ Jugar</button>
          <button class="btn" id="btnPause" type="button" aria-pressed="false">‚è∏ Pausa</button>
          <button class="btn" id="btnSound" type="button" aria-pressed="true" title="Activar o silenciar sonidos">üîä Sonido</button>
          <button class="btn btn-danger" id="btnRestartTop" type="button" style="display:none;">‚Üª Reintentar</button>
        </div>
      </div>

      <div class="game-container" id="gameContainer">
        <div class="hud-overlay">
          <div class="left">
            <div class="chip">ü™ô Monedas: <b id="hudCoins">0</b> <span class="sub">(+<b id="hudCoinsRun">0</b>)</span></div>
            <div class="chip">üéØ Nivel: <b id="hudLevel">1</b></div>
            <div class="chip">‚ù§Ô∏è Vidas: <b id="hudLives">3</b></div>
          </div>
          <div class="right">
            <div class="chip">‚≠ê Puntaje: <b id="hudScore">0</b></div>
            <div class="chip">üèÜ R√©cord: <b id="hudBest">0</b></div>
          </div>
        </div>

        <canvas id="cv" width="900" height="540"></canvas>

        <div class="joystick" id="joystick" aria-label="Joystick">
          <div class="joy-base" id="joyBase" aria-hidden="true"></div>
          <div class="joy-knob" id="joyKnob" aria-hidden="true"></div>
        </div>

        <div id="startOverlay" class="overlay show" role="dialog" aria-modal="true">
          <div class="card">
            <div class="icon" aria-hidden="true">üü°</div>
            <div>
              <h2>Listo para jugar</h2>
              <p>Recoge <b>monedas</b>, activa s√∫per poder con las monedas grandes y evita a los fantasmas. Las monedas de la partida se suman a tu billetera al terminar.</p>
              <div class="row">
                <button class="btn btn-primary" id="btnStart" type="button">‚ñ∂ Empezar</button>
                <button class="btn" id="btnHow" type="button">C√≥mo funciona</button>
              </div>
              <div class="mini" id="howText" style="display:none">
                ‚Ä¢ PC: flechas o WASD. Pausa: ESPACIO.<br/>
                ‚Ä¢ M√≥vil: gira el tel√©fono y usa √∫nicamente el joystick (no toques el tablero).<br/>
                ‚Ä¢ Moneda grande: fantasmas asustados por unos segundos (puedes capturarlos para bonus).
              </div>
            </div>
          </div>
        </div>

        <div id="rotateHint" class="overlay" aria-hidden="true">
          <div class="card">
            <div class="icon" aria-hidden="true">‚Üî</div>
            <div>
              <h2>Gira el tel√©fono</h2>
              <p>Para jugar bien, usa el modo horizontal. El tablero se ajusta autom√°ticamente.</p>
              <div class="mini">En iPhone, para verlo tipo app sin barras: Compartir ‚Üí A√±adir a pantalla de inicio.</div>
            </div>
          </div>
        </div>

        <div id="gameOverOverlay" class="overlay" aria-hidden="true">
          <div class="card">
            <div class="icon" aria-hidden="true">üí•</div>
            <div>
              <h2 id="goTitle">Fin de partida</h2>
              <p id="goStats">‚Äî</p>
              <div class="row">
                <button class="btn btn-primary" id="btnRestart" type="button">‚Üª Reintentar</button>
              </div>
              <div class="mini">Tip: en intersecciones, decide antes de llegar al centro de la celda para girar perfecto.</div>
            </div>
          </div>
        </div>

        <div id="pauseOverlay" class="overlay" aria-hidden="true">
          <div class="card">
            <div class="icon" aria-hidden="true">‚è∏</div>
            <div>
              <h2>Pausado</h2>
              <p>Cuando est√©s listo, reanuda la partida.</p>
              <div class="row">
                <button class="btn btn-primary" id="btnResume" type="button">‚ñ∂ Reanudar</button>
                <button class="btn btn-danger" id="btnRestart2" type="button">‚Üª Reiniciar</button>
              </div>
              <div class="mini">En m√≥vil, usa √∫nicamente el joystick para mover el personaje.</div>
            </div>
          </div>
        </div>

        <div id="iosHint" style="display:none"></div>
      </div>
    </div>
  </div>

<script>
(() => {
"use strict";

/* ---------------------------------------------------------
 *  Identidad + Wallet (compatible con panel)
 * --------------------------------------------------------- */
const user = localStorage.getItem("juego_user") || "Invitado";
document.getElementById("hello").textContent = "Jugador: " + user;

const WALLET_KEY = `rz_wallet_${user}`;
function loadWallet(){
  const w = JSON.parse(localStorage.getItem(WALLET_KEY) || "null");
  if(w) return w;
  const fresh = { coins: 0, level: 1, xp: 0 };
  localStorage.setItem(WALLET_KEY, JSON.stringify(fresh));
  return fresh;
}
function saveWallet(w){
  localStorage.setItem(WALLET_KEY, JSON.stringify(w));
  // Keep header level in sync
  hudCoins.textContent = String(w.coins|0);
  hudLevel.textContent = String(w.level|0);
}
function addCoins(n){
  const w = loadWallet();
  w.coins = Math.max(0, (w.coins|0) + (n|0));
  saveWallet(w);
}
function addXp(n){
  const w = loadWallet();
  w.xp = Math.max(0, (w.xp|0) + (n|0));
  const newLevel = 1 + Math.floor(w.xp / 250);
  if(newLevel > (w.level|0)){
    w.level = newLevel;
  }
  saveWallet(w);
}

/* ---------------------------------------------------------
 *  Responsive fit + rotate hint + iOS hint (mismo est√°ndar Snake)
 * --------------------------------------------------------- */
const cv = document.getElementById("cv");
const gameContainer = document.getElementById("gameContainer");
const rotateHint = document.getElementById("rotateHint");
const startOverlay = document.getElementById("startOverlay");
const gameOverOverlay = document.getElementById("gameOverOverlay");
const pauseOverlay = document.getElementById("pauseOverlay");
const iosHint = document.getElementById("iosHint");
let awaitingLandscapeTap = false;

const GAME_W = cv.width;
const GAME_H = cv.height;

function isIOS(){ return /iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream; }
function isStandalone(){ return (window.navigator.standalone === true) || window.matchMedia("(display-mode: standalone)").matches; }

function showIOSHint(){
  const isMobile = Math.min(window.innerWidth, window.innerHeight) <= 900;
  if(isIOS() && isMobile && !isStandalone()){
    iosHint.style.display = "block";
    iosHint.innerHTML = `
      <div class="row">
        <div>
          <div class="ttl">iPhone (Safari)</div>
          <div class="mut">Safari no permite pantalla completa real en la web. Para verlo como app (sin barras), usa: <b>Compartir ‚Üí A√±adir a pantalla de inicio</b> y √°brelo desde ah√≠.</div>
        </div>
        <button class="x" type="button" aria-label="Cerrar">‚úï</button>
      </div>
    `;
    iosHint.querySelector(".x")?.addEventListener("click", () => (iosHint.style.display = "none"), { once:true });
  } else {
    iosHint.style.display = "none";
  }
}

async function requestFullscreenSafe(){
  const el = document.documentElement;
  try{
    if(el.requestFullscreen) await el.requestFullscreen();
    else if(el.webkitRequestFullscreen) await el.webkitRequestFullscreen();
  }catch(_){}
}

function maybeAutoFullscreen(){
  if(isIOS()) return;
  if(document.fullscreenElement) return;
  if(awaitingLandscapeTap){
    requestFullscreenSafe();
    awaitingLandscapeTap = false;
  }
}

function applyFit(){
  const vv = window.visualViewport;
  const vw = vv ? vv.width : window.innerWidth;
  const vh = vv ? vv.height : window.innerHeight;

  const rect = gameContainer.getBoundingClientRect();
  const styles = getComputedStyle(gameContainer);
  const padX = parseFloat(styles.paddingLeft||"0") + parseFloat(styles.paddingRight||"0");
  const padY = parseFloat(styles.paddingTop||"0") + parseFloat(styles.paddingBottom||"0");

  const availW = Math.max(0, rect.width - padX);
  const availH = Math.max(0, rect.height - padY);

  const scale = Math.max(0.1, Math.min(availW / GAME_W, availH / GAME_H));
  cv.style.width  = Math.floor(GAME_W * scale) + "px";
  cv.style.height = Math.floor(GAME_H * scale) + "px";

  const isMobile = Math.min(vw, vh) <= 900;
  const isPortrait = vh > vw;
  const isLandscape = vw > vh;

  rotateHint.classList.toggle("show", (isMobile && isPortrait));
  rotateHint.setAttribute("aria-hidden", rotateHint.classList.contains("show") ? "false" : "true");

  document.body.classList.toggle("mobile-land", (isMobile && isLandscape && !rotateHint.classList.contains("show")));

  if(isMobile && isLandscape && !isIOS() && !document.fullscreenElement){
    awaitingLandscapeTap = true;
  } else {
    awaitingLandscapeTap = false;
  }

  document.body.classList.toggle("fs", !!document.fullscreenElement);

  showIOSHint();
  window.scrollTo(0, 1);
}

window.addEventListener("resize", () => setTimeout(applyFit, 60), { passive:true });
window.addEventListener("orientationchange", () => setTimeout(applyFit, 160), { passive:true });
if(window.visualViewport){ window.visualViewport.addEventListener("resize", () => setTimeout(applyFit, 60), { passive:true }); }
document.addEventListener("fullscreenchange", () => setTimeout(applyFit, 60));
document.addEventListener("touchend", () => setTimeout(applyFit, 60), { passive:true });

document.addEventListener("pointerdown", () => { maybeAutoFullscreen(); }, { passive:true });

applyFit();
showIOSHint();

/* ---------------------------------------------------------
 *  UI bindings
 * --------------------------------------------------------- */
const hudScore = document.getElementById("hudScore");
const hudCoins = document.getElementById("hudCoins");
const hudCoinsRun = document.getElementById("hudCoinsRun");
const hudLevel = document.getElementById("hudLevel");
const hudLives = document.getElementById("hudLives");
const hudBest = document.getElementById("hudBest");

const btnBack = document.getElementById("btnBack");
const btnStartTop = document.getElementById("btnStartTop");
const btnPause = document.getElementById("btnPause");
const btnSound = document.getElementById("btnSound");
const btnRestartTop = document.getElementById("btnRestartTop");

const btnStart = document.getElementById("btnStart");
const btnHow = document.getElementById("btnHow");
const howText = document.getElementById("howText");
const btnRestart = document.getElementById("btnRestart");
const btnResume = document.getElementById("btnResume");
const btnRestart2 = document.getElementById("btnRestart2");
const goTitle = document.getElementById("goTitle");
const goStats = document.getElementById("goStats");

btnBack.addEventListener("click", () => (window.location.href = "panel.html"));
btnHow.addEventListener("click", () => {
  howText.style.display = (howText.style.display === "none") ? "block" : "none";
});

/* ---------------------------------------------------------
 *  Persistencia (r√©cord + sonido)
 * --------------------------------------------------------- */
const BEST_KEY = `rz_best_rinopac_${user}`;
const SOUND_KEY = "rinopac_sound_on_v1";

function getBest(){ return Math.floor(Number(localStorage.getItem(BEST_KEY) || "0")) || 0; }
function setBest(v){ localStorage.setItem(BEST_KEY, String(v|0)); }

let bestScore = getBest();
hudBest.textContent = String(bestScore);

let soundOn = (localStorage.getItem(SOUND_KEY) ?? "1") !== "0";
let audioEnabled = false;
let fxCtx = null;
let masterGain = null;

function getFxCtx(){
  if(!fxCtx){
    const AC = window.AudioContext || window.webkitAudioContext;
    if(AC) fxCtx = new AC();
  }
  return fxCtx;
}
function ensureAudioGraph(){
  const ac = getFxCtx(); if(!ac) return null;
  if(!masterGain){
    masterGain = ac.createGain();
    masterGain.gain.value = soundOn ? 0.9 : 0.0;
    masterGain.connect(ac.destination);
  } else {
    masterGain.gain.value = soundOn ? 0.9 : 0.0;
  }
  return ac;
}
function setSoundOn(v){
  soundOn = !!v;
  localStorage.setItem(SOUND_KEY, soundOn ? "1" : "0");
  if(masterGain) masterGain.gain.value = soundOn ? 0.9 : 0.0;
}
function fxBeep(steps, dur = 0.20, vol = 0.16, type="triangle"){
  if(!audioEnabled || !soundOn) return;
  const ac = getFxCtx(); if(!ac) return;
  if(ac.state === "suspended") ac.resume();
  const now = ac.currentTime;
  const osc = ac.createOscillator();
  const gain = ac.createGain();
  const filter = ac.createBiquadFilter();
  ensureAudioGraph();
  osc.type = type;
  filter.type = "lowpass";
  filter.frequency.setValueAtTime(2200, now);
  gain.gain.setValueAtTime(vol, now);
  gain.gain.exponentialRampToValueAtTime(0.001, now + dur);
  osc.connect(filter); filter.connect(gain); gain.connect(masterGain || ac.destination);
  for(const s of steps) osc.frequency.setValueAtTime(s.freq, now + s.time);
  osc.start(now); osc.stop(now + dur + 0.02);
}
function playFx(kind){
  if(!audioEnabled || !soundOn) return;
  switch(kind){
    case "coin": fxBeep([{time:0.00,freq:980},{time:0.05,freq:1250},{time:0.10,freq:1560}],0.16,0.16,"triangle"); break;
    case "power": fxBeep([{time:0.00,freq:520},{time:0.06,freq:780},{time:0.12,freq:980}],0.22,0.16,"triangle"); break;
    case "ghost": fxBeep([{time:0.00,freq:420},{time:0.06,freq:610},{time:0.12,freq:820}],0.22,0.17,"triangle"); break;
    case "hit": fxBeep([{time:0.00,freq:260},{time:0.06,freq:190},{time:0.12,freq:140}],0.22,0.18,"square"); break;
    case "start": fxBeep([{time:0.00,freq:520},{time:0.07,freq:680},{time:0.14,freq:820}],0.20,0.15,"triangle"); break;
    case "levelup": fxBeep([{time:0.00,freq:660},{time:0.06,freq:880},{time:0.12,freq:1180}],0.22,0.16,"triangle"); break;
  }
}
if(btnSound){
  btnSound.setAttribute("aria-pressed", soundOn ? "true" : "false");
  btnSound.textContent = soundOn ? "üîä Sonido" : "üîá Silencio";
  btnSound.addEventListener("click", () => {
    setSoundOn(!soundOn);
    btnSound.setAttribute("aria-pressed", soundOn ? "true" : "false");
    btnSound.textContent = soundOn ? "üîä Sonido" : "üîá Silencio";
  });
}

function vibrate(kind){
  if(!("vibrate" in navigator)) return;
  if(window.matchMedia && window.matchMedia("(prefers-reduced-motion: reduce)").matches) return;
  switch(kind){
    case "coin": navigator.vibrate(10); break;
    case "power": navigator.vibrate([16, 30, 16]); break;
    case "hit": navigator.vibrate([25, 40, 25, 40, 25]); break;
  }
}

/* ---------------------------------------------------------
 *  Juego (Pacman-like) ‚Äî enfocado a monedas
 * --------------------------------------------------------- */
const ctx = cv.getContext("2d", { alpha:true });
const W = cv.width, H = cv.height;

// Base map (0 empty, 1 wall, 2 coin, 3 power coin)
const BASE_MAP_STR = [
  "111111111111111111111",
  "120000000010000000021",
  "101111011010110111101",
  "103000010000010000301",
  "101111011111110111101",
  "100000000010000000001",
  "101111011010110111101",
  "100010000000000010001",
  "111011111010111110111",
  "100000000000000000001",
  "101111011111110111101",
  "103000010000010000301",
  "101111011010110111101",
  "120000000010000000021",
  "111111111111111111111",
];

function buildMap(){
  return BASE_MAP_STR.map(row => row.split("").map(ch => +ch));
}
let MAP = buildMap();
const rows = MAP.length;
const cols = MAP[0].length;

// Tile sizing in canvas coordinates
function computeTile(){
  const margin = 26;
  const tile = Math.floor(Math.min((W - margin*2)/cols, (H - margin*2)/rows));
  const gridW = cols*tile;
  const gridH = rows*tile;
  const ox = Math.floor((W - gridW)/2);
  const oy = Math.floor((H - gridH)/2);
  return { tile, gridW, gridH, ox, oy, margin };
}
const geom = computeTile();
let tile = geom.tile, ox = geom.ox, oy = geom.oy;

function cellAt(px, py){
  const c = Math.floor((px - ox)/tile);
  const r = Math.floor((py - oy)/tile);
  return { r, c };
}
function isWall(r,c){
  if(r<0||c<0||r>=rows||c>=cols) return true;
  return MAP[r][c] === 1;
}
function atCenter(e){
  // entity considered centered when close enough to cell center
  const c = Math.floor((e.x - ox)/tile);
  const r = Math.floor((e.y - oy)/tile);
  const cx = ox + c*tile + tile/2;
  const cy = oy + r*tile + tile/2;
  return (Math.abs(e.x - cx) < 1.2) && (Math.abs(e.y - cy) < 1.2);
}
function canMoveDir(e, d){
  const cur = cellAt(e.x, e.y);
  const nr = cur.r + d.y;
  const nc = cur.c + d.x;
  return !isWall(nr, nc);
}
function snapToGrid(e){
  const cur = cellAt(e.x, e.y);
  e.x = ox + cur.c*tile + tile/2;
  e.y = oy + cur.r*tile + tile/2;
}

let running=false, paused=false, over=false;

let score=0;
let runCoins=0;
let lives=3;
let pelletsLeft=0;
let levelLocal=1;

let frightened = 0; // seconds
let comboGhost = 0;
let startGrace = 0; // segundos de ‚Äúgracia‚Äù al iniciar/respawn (evita muerte instant√°nea)

const SPEED_BASE = 160; // px/s (scaled with level)
const PAC = {
  x:0, y:0,
  dir:{x:1,y:0},
  next:{x:1,y:0},
  r: Math.max(10, Math.floor(tile*0.36)),
  mouth: 0,
  inv: 0,
};

const GHOSTS = [
  // Nota: los fantasmas NO aparecen encima del jugador (evita ‚Äúmuerte instant√°nea‚Äù al iniciar)
  {name:"Aqua",  color:"rgba(56,189,248,.95)", x:0,y:0, dir:{x:-1,y:0}, home:{r:7,c:9}},
  {name:"Rose",  color:"rgba(251,113,133,.95)", x:0,y:0, dir:{x:1,y:0},  home:{r:7,c:10}},
  {name:"Mint",  color:"rgba(34,197,94,.95)",  x:0,y:0, dir:{x:0,y:-1}, home:{r:7,c:11}},
];

function countPellets(){
  pelletsLeft = 0;
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const v = MAP[r][c];
      if(v===2||v===3) pelletsLeft++;
    }
  }
}

function placeEntities(){
  const pr = 9, pc = 10;
  PAC.x = ox + pc*tile + tile/2;
  PAC.y = oy + pr*tile + tile/2;
  PAC.dir = {x:1,y:0};
  PAC.next = {x:1,y:0};
  PAC.inv = 0;
  PAC.mouth = 0;

  for(const g of GHOSTS){
    g.x = ox + g.home.c*tile + tile/2;
    g.y = oy + g.home.r*tile + tile/2;
    g.dir = {x: (Math.random()<.5?1:-1), y:0};
  }
}

function updateHUD(){
  hudScore.textContent = String(score|0);
  hudLives.textContent = String(lives|0);
  hudCoinsRun.textContent = String(runCoins|0);
  // wallet coins + level
  const w = loadWallet();
  hudCoins.textContent = String(w.coins|0);
  hudLevel.textContent = String(w.level|0);
  hudBest.textContent = String(bestScore|0);
}

function resetGame(keepOverlays=false){
  running = false;
  paused = false;
  over = false;

  score = 0;
  runCoins = 0;
  lives = 3;
  levelLocal = 1;
  frightened = 0;
  comboGhost = 0;
  startGrace = 1.6;

  MAP = buildMap();
  countPellets();
  placeEntities();
  updateHUD();

  btnPause.setAttribute("aria-pressed", "false");
  btnPause.textContent = "‚è∏ Pausa";
  btnRestartTop.style.display = "none";

  if(!keepOverlays){
    startOverlay.classList.add("show");
    startOverlay.setAttribute("aria-hidden","false");
  }
  pauseOverlay.classList.remove("show");
  pauseOverlay.setAttribute("aria-hidden","true");
  gameOverOverlay.classList.remove("show");
  gameOverOverlay.setAttribute("aria-hidden","true");

  draw();
}

function setPaused(p){
  paused = !!p;
  btnPause.setAttribute("aria-pressed", paused ? "true" : "false");
  btnPause.textContent = paused ? "‚ñ∂ Reanudar" : "‚è∏ Pausa";
  pauseOverlay.classList.toggle("show", paused);
  pauseOverlay.setAttribute("aria-hidden", paused ? "false" : "true");
}

function endRun(reason){
  running = false;
  paused = false;
  over = true;

  // persist: add coins to wallet
  if(runCoins > 0) addCoins(runCoins);
  // best
  if(score > bestScore){
    bestScore = score|0;
    setBest(bestScore);
  }
  updateHUD();

  btnRestartTop.style.display = "inline-flex";
  playFx("hit");
  vibrate("hit");

  goTitle.textContent = reason || "Fin de partida";
  goStats.textContent = `Puntaje: ${score|0} ¬∑ Monedas (partida): ${runCoins|0} ¬∑ Nivel interno: ${levelLocal|0}`;
  gameOverOverlay.classList.add("show");
  gameOverOverlay.setAttribute("aria-hidden","false");
}

function startGame(){
  // unlock audio on first gesture
  audioEnabled = true;
  const ac = ensureAudioGraph();
  if(ac && ac.state === "suspended") ac.resume();

  resetGame(true);
  running = true;
  paused = false;
  over = false;
  startGrace = 1.6;

  startOverlay.classList.remove("show");
  startOverlay.setAttribute("aria-hidden","true");
  gameOverOverlay.classList.remove("show");
  gameOverOverlay.setAttribute("aria-hidden","true");

  playFx("start");
  loopStart();
}

/* ---------------------------------------------------------
 *  Movement + collision
 * --------------------------------------------------------- */
function tryTurn(e){
  if(!atCenter(e)) return;
  if(canMoveDir(e, e.next)){
    e.dir = {x:e.next.x, y:e.next.y};
  }
}

function moveEntity(e, speed, dt){
  // dt in seconds
  // if at center, stop if wall ahead
  if(atCenter(e) && !canMoveDir(e, e.dir)){
    e.dir = {x:0,y:0};
    return;
  }
  e.x += e.dir.x * speed * dt;
  e.y += e.dir.y * speed * dt;

  // keep inside bounds softly
  const minX = ox + tile/2, maxX = ox + (cols-1)*tile + tile/2;
  const minY = oy + tile/2, maxY = oy + (rows-1)*tile + tile/2;
  e.x = Math.max(minX, Math.min(maxX, e.x));
  e.y = Math.max(minY, Math.min(maxY, e.y));
}

function eatIfAny(){
  const cell = cellAt(PAC.x, PAC.y);
  if(cell.r<0||cell.c<0||cell.r>=rows||cell.c>=cols) return;
  const v = MAP[cell.r][cell.c];
  if(v === 2){
    MAP[cell.r][cell.c] = 0;
    pelletsLeft--;
    // monedas: 1 por pellet
    runCoins += 1;
    score += 10;
    addXp(1);
    playFx("coin");
    vibrate("coin");
  } else if(v === 3){
    MAP[cell.r][cell.c] = 0;
    pelletsLeft--;
    runCoins += 5;
    score += 60;
    addXp(6);
    frightened = 7.0;
    comboGhost = 0;
    playFx("power");
    vibrate("power");
  }
}

function ghostAI(g){
  if(!atCenter(g)) return;

  const options = [];
  const dirs = [{x:1,y:0},{x:-1,y:0},{x:0,y:1},{x:0,y:-1}];

  for(const d of dirs){
    const isReverse = (d.x === -g.dir.x && d.y === -g.dir.y);
    if(isReverse) continue;
    if(canMoveDir(g, d)) options.push(d);
  }
  if(options.length === 0){
    // allow reverse if trapped
    for(const d of dirs){
      if(canMoveDir(g, d)) options.push(d);
    }
  }
  if(options.length === 0){
    g.dir = {x:0,y:0};
    return;
  }

  const pacCell = cellAt(PAC.x, PAC.y);
  const gCell = cellAt(g.x, g.y);

  function scoreDir(d){
    const nr = gCell.r + d.y;
    const nc = gCell.c + d.x;
    const dist = Math.abs(pacCell.r - nr) + Math.abs(pacCell.c - nc);
    return dist + (Math.random()*0.10); // slight noise
  }

  if(frightened > 0){
    // flee: maximize distance
    let best = options[0], bestVal = -1e9;
    for(const d of options){
      const nr = gCell.r + d.y;
      const nc = gCell.c + d.x;
      const dist = Math.abs(pacCell.r - nr) + Math.abs(pacCell.c - nc);
      if(dist > bestVal){ bestVal = dist; best = d; }
    }
    if(Math.random() < 0.20) best = options[Math.floor(Math.random()*options.length)];
    g.dir = best;
  } else {
    // chase: minimize distance
    let best = options[0], bestVal = 1e9;
    for(const d of options){
      const val = scoreDir(d);
      if(val < bestVal){ bestVal = val; best = d; }
    }
    if(Math.random() < 0.14) best = options[Math.floor(Math.random()*options.length)];
    g.dir = best;
  }
}

/* ---------------------------------------------------------
 *  Update + render loop (dt clamp, no spiral)
 * --------------------------------------------------------- */
let rafId = null;
let lastTs = 0;

function loopStart(){
  if(rafId) return;
  const loop = (ts) => {
    rafId = requestAnimationFrame(loop);
    if(!lastTs) lastTs = ts;
    const dt = Math.min(0.03, (ts - lastTs) / 1000); // clamp
    lastTs = ts;

    if(!running){
      draw();
      return;
    }
    if(paused){
      draw();
      return;
    }

    update(dt);
    draw();
  };
  rafId = requestAnimationFrame(loop);
}

function update(dt){
  // power timer
  if(frightened > 0){
    frightened -= dt;
    if(frightened <= 0){
      frightened = 0;
      comboGhost = 0;
    }
  }
  if(PAC.inv > 0) PAC.inv -= dt;
  if(startGrace > 0) startGrace -= dt;

  // smooth speed scaling with internal level
  const k = 1 + (levelLocal-1)*0.08;
  const pacSpeed = SPEED_BASE * k;
  const ghostSpeed = (SPEED_BASE * 0.92) * k * (frightened>0 ? 0.82 : 1.0);

  tryTurn(PAC);
  moveEntity(PAC, pacSpeed, dt);
  eatIfAny();

  for(const g of GHOSTS){
    ghostAI(g);
    moveEntity(g, ghostSpeed, dt);
  }

  // collisions (durante startGrace no se pierde vida)
  if(startGrace <= 0){
  for(const g of GHOSTS){
    const dx = g.x - PAC.x;
    const dy = g.y - PAC.y;
    const dist = Math.hypot(dx,dy);
    if(dist < PAC.r*1.05){
      if(frightened > 0){
        comboGhost++;
        const bonus = 200 * comboGhost;
        score += bonus;
        runCoins += 8; // reward coins for ghost capture
        addXp(12 + 2*comboGhost);
        playFx("ghost");
        vibrate("power");
        // send ghost home
        g.x = ox + g.home.c*tile + tile/2;
        g.y = oy + g.home.r*tile + tile/2;
        g.dir = {x:(Math.random()<.5?1:-1), y:0};
      } else if(PAC.inv <= 0){
        lives--;
        PAC.inv = 1.4;
        startGrace = 1.2;
        playFx("hit");
        vibrate("hit");
        if(lives <= 0){
          updateHUD();
          endRun("Sin vidas");
          return;
        }
        placeEntities();
      }
    }
  }
  }

  // level clear
  if(pelletsLeft <= 0){
    levelLocal++;
    // new map
    MAP = buildMap();
    countPellets();
    placeEntities();
    score += 150;
    addXp(30);
    playFx("levelup");
    vibrate("power");
  }

  // passive score for survival
  score += 6 * dt * (1 + (levelLocal-1)*0.12);

  updateHUD();
}

/* ---------------------------------------------------------
 *  Render (paredes + monedas + pac + fantasmas)
 * --------------------------------------------------------- */
function draw(){
  ctx.clearRect(0,0,W,H);

  // subtle background glow + vignette
  const bg = ctx.createLinearGradient(0,0,0,H);
  bg.addColorStop(0, "rgba(11,18,36,1)");
  bg.addColorStop(1, "rgba(2,6,23,1)");
  ctx.fillStyle = bg;
  ctx.fillRect(0,0,W,H);

  // draw maze walls
  ctx.save();
  ctx.translate(ox, oy);

  // outer soft glow
  ctx.globalCompositeOperation = "lighter";
  ctx.fillStyle = "rgba(56,189,248,0.05)";
  ctx.fillRect(-10,-10, cols*tile+20, rows*tile+20);
  ctx.globalCompositeOperation = "source-over";

  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      const v = MAP[r][c];
      const x = c*tile, y = r*tile;

      if(v === 1){
        // wall tile
        const g = ctx.createLinearGradient(x,y,x+tile,y+tile);
        g.addColorStop(0,"rgba(56,189,248,0.40)");
        g.addColorStop(1,"rgba(167,139,250,0.22)");
        ctx.fillStyle = "rgba(15,23,42,0.92)";
        roundRect(ctx, x+1, y+1, tile-2, tile-2, Math.max(6, tile*0.22));
        ctx.fill();
        ctx.strokeStyle = g;
        ctx.lineWidth = Math.max(1.2, tile*0.06);
        ctx.stroke();
      } else if(v === 2 || v === 3){
        // coin / power coin
        const cx = x + tile/2;
        const cy = y + tile/2;
        const isPower = (v===3);
        const r0 = isPower ? tile*0.22 : tile*0.12;

        // glow
        ctx.globalCompositeOperation = "lighter";
        const glow = ctx.createRadialGradient(cx,cy,0, cx,cy, r0*3.2);
        glow.addColorStop(0, isPower ? "rgba(250,204,21,0.30)" : "rgba(250,204,21,0.18)");
        glow.addColorStop(1, "rgba(250,204,21,0)");
        ctx.fillStyle = glow;
        ctx.beginPath(); ctx.arc(cx,cy,r0*3.2,0,Math.PI*2); ctx.fill();
        ctx.globalCompositeOperation = "source-over";

        // coin body
        const cg = ctx.createRadialGradient(cx - r0*0.35, cy - r0*0.35, 0, cx, cy, r0*1.2);
        cg.addColorStop(0,"rgba(255,255,255,0.95)");
        cg.addColorStop(0.18,"rgba(250,204,21,0.95)");
        cg.addColorStop(1,"rgba(245,158,11,0.92)");
        ctx.fillStyle = cg;
        ctx.beginPath(); ctx.arc(cx,cy,r0,0,Math.PI*2); ctx.fill();
        ctx.strokeStyle = "rgba(255,255,255,0.20)";
        ctx.lineWidth = Math.max(1, tile*0.04);
        ctx.stroke();

        if(isPower){
          // ring pulse
          const t = (performance.now()/1000);
          const pulse = 0.5 + 0.5*Math.sin(t*4.2);
          ctx.strokeStyle = `rgba(56,189,248,${0.18 + 0.18*pulse})`;
          ctx.lineWidth = Math.max(1, tile*0.05);
          ctx.beginPath(); ctx.arc(cx,cy,r0*(1.8 + 0.25*pulse),0,Math.PI*2); ctx.stroke();
        }
      }
    }
  }
  ctx.restore();

  // entities
  drawPac();
  for(const g of GHOSTS) drawGhost(g);

  if(paused){
    // handled by overlay; keep subtle dim
    ctx.fillStyle = "rgba(0,0,0,0.18)";
    ctx.fillRect(0,0,W,H);
  }
}

function drawPac(){
  const t = performance.now()/1000;
  const mouth = running && !paused ? (0.25 + 0.25*Math.sin(t*10)) : 0.22;
  const a0 = mouth;
  const a1 = Math.PI*2 - mouth;

  // inv blink
  const invBlink = (PAC.inv > 0) ? (Math.sin(t*18) > 0 ? 0.45 : 1.0) : 1.0;

  ctx.save();
  ctx.globalAlpha = invBlink;

  // glow
  ctx.globalCompositeOperation = "lighter";
  const glow = ctx.createRadialGradient(PAC.x,PAC.y,0, PAC.x,PAC.y, PAC.r*3.2);
  glow.addColorStop(0,"rgba(250,204,21,0.20)");
  glow.addColorStop(1,"rgba(250,204,21,0)");
  ctx.fillStyle = glow;
  ctx.beginPath(); ctx.arc(PAC.x,PAC.y,PAC.r*3.2,0,Math.PI*2); ctx.fill();
  ctx.globalCompositeOperation = "source-over";

  // body
  const g = ctx.createRadialGradient(PAC.x - PAC.r*0.35, PAC.y - PAC.r*0.35, 0, PAC.x, PAC.y, PAC.r*1.25);
  g.addColorStop(0,"rgba(255,255,255,0.95)");
  g.addColorStop(0.20,"rgba(250,204,21,0.98)");
  g.addColorStop(1,"rgba(245,158,11,0.96)");
  ctx.fillStyle = g;

  const dirAngle = Math.atan2(PAC.dir.y, PAC.dir.x) || 0;
  ctx.beginPath();
  ctx.moveTo(PAC.x, PAC.y);
  ctx.arc(PAC.x, PAC.y, PAC.r, dirAngle + a0, dirAngle + a1, false);
  ctx.closePath();
  ctx.fill();

  ctx.strokeStyle = "rgba(255,255,255,0.18)";
  ctx.lineWidth = Math.max(1, PAC.r*0.14);
  ctx.stroke();

  // eye
  ctx.fillStyle = "rgba(2,6,23,0.85)";
  ctx.beginPath();
  ctx.arc(PAC.x + Math.cos(dirAngle+0.9)*PAC.r*0.35, PAC.y + Math.sin(dirAngle+0.9)*PAC.r*0.35, Math.max(1.4, PAC.r*0.11), 0, Math.PI*2);
  ctx.fill();

  ctx.restore();
}

function drawGhost(g){
  const t = performance.now()/1000;
  const s = Math.sin(t*6 + g.x*0.01);
  const r = Math.max(10, Math.floor(tile*0.34));

  const scared = frightened > 0;
  const bodyColor = scared ? "rgba(148,163,184,0.92)" : g.color;

  ctx.save();

  // glow
  ctx.globalCompositeOperation = "lighter";
  const glow = ctx.createRadialGradient(g.x,g.y,0, g.x,g.y, r*3);
  glow.addColorStop(0, scared ? "rgba(203,213,245,0.14)" : "rgba(56,189,248,0.10)");
  glow.addColorStop(1, "rgba(0,0,0,0)");
  ctx.fillStyle = glow;
  ctx.beginPath(); ctx.arc(g.x,g.y,r*3,0,Math.PI*2); ctx.fill();
  ctx.globalCompositeOperation = "source-over";

  // body
  ctx.fillStyle = bodyColor;
  ctx.beginPath();
  ctx.arc(g.x, g.y - r*0.25, r, Math.PI, 0);
  ctx.lineTo(g.x + r, g.y + r*0.9);
  // wavy bottom
  const waves = 3;
  for(let i=0;i<waves;i++){
    const wx = g.x + r - (i+1)*(2*r/(waves+1));
    const wy = g.y + r*0.9 + (i%2===0? r*0.18 : -r*0.18)*s;
    ctx.quadraticCurveTo(wx, wy, g.x + r - (i+1)*(2*r/(waves+1)) - (2*r/(waves+1))/2, g.y + r*0.9);
  }
  ctx.closePath();
  ctx.fill();

  ctx.strokeStyle = "rgba(255,255,255,0.14)";
  ctx.lineWidth = Math.max(1, r*0.10);
  ctx.stroke();

  // eyes
  const eyeDx = r*0.32;
  const eyeY = g.y - r*0.18;
  ctx.fillStyle = "rgba(255,255,255,0.92)";
  ctx.beginPath(); ctx.arc(g.x-eyeDx, eyeY, r*0.22, 0, Math.PI*2); ctx.arc(g.x+eyeDx, eyeY, r*0.22, 0, Math.PI*2); ctx.fill();

  ctx.fillStyle = "rgba(2,6,23,0.85)";
  const pdx = (scared? 0 : (g.dir.x*0.10))*r;
  const pdy = (scared? 0 : (g.dir.y*0.10))*r;
  ctx.beginPath(); ctx.arc(g.x-eyeDx+pdx, eyeY+pdy, r*0.10, 0, Math.PI*2); ctx.arc(g.x+eyeDx+pdx, eyeY+pdy, r*0.10, 0, Math.PI*2); ctx.fill();

  if(scared){
    // mouth
    ctx.strokeStyle = "rgba(2,6,23,0.7)";
    ctx.lineWidth = Math.max(1, r*0.10);
    ctx.beginPath();
    ctx.arc(g.x, g.y + r*0.25, r*0.26, 0, Math.PI);
    ctx.stroke();
  }

  ctx.restore();
}

function roundRect(ctx, x, y, w, h, r){
  const rr = Math.min(r, w*0.5, h*0.5);
  ctx.beginPath();
  ctx.moveTo(x+rr, y);
  ctx.arcTo(x+w, y, x+w, y+h, rr);
  ctx.arcTo(x+w, y+h, x, y+h, rr);
  ctx.arcTo(x, y+h, x, y, rr);
  ctx.arcTo(x, y, x+w, y, rr);
  ctx.closePath();
}

/* ---------------------------------------------------------
 *  Input: teclado + joystick
 * --------------------------------------------------------- */
function setNextDir(nx, ny){
  // ignore if same
  if(nx === PAC.next.x && ny === PAC.next.y) return;
  PAC.next = {x:nx, y:ny};
}

window.addEventListener("keydown", (e) => {
  const k = e.key.toLowerCase();
  if(k === "arrowup" || k === "w"){ setNextDir(0,-1); e.preventDefault(); }
  else if(k === "arrowdown" || k === "s"){ setNextDir(0,1); e.preventDefault(); }
  else if(k === "arrowleft" || k === "a"){ setNextDir(-1,0); e.preventDefault(); }
  else if(k === "arrowright" || k === "d"){ setNextDir(1,0); e.preventDefault(); }
  else if(k === " "){
    // pause
    if(running && !over){
      setPaused(!paused);
    }
    e.preventDefault();
  }
}, { passive:false });

// Buttons
btnStartTop.addEventListener("click", () => startGame());
btnStart.addEventListener("click", () => startGame());
btnRestartTop.addEventListener("click", () => { resetGame(true); startGame(); });
btnRestart.addEventListener("click", () => { resetGame(true); startGame(); });
btnPause.addEventListener("click", () => {
  if(!running || over) return;
  setPaused(!paused);
});
btnResume.addEventListener("click", () => setPaused(false));
btnRestart2.addEventListener("click", () => { setPaused(false); resetGame(true); startGame(); });

// Prevent scroll in game
document.addEventListener("touchmove", (e) => e.preventDefault(), { passive:false });

// Joystick (mobile)
const joystick = document.getElementById("joystick");
const joyKnob = document.getElementById("joyKnob");

let joyActive = false;
let joyCenter = {x:0,y:0};
const joyMax = 34;

function joySetKnob(dx, dy){
  const dist = Math.hypot(dx,dy);
  const k = dist > joyMax ? (joyMax/dist) : 1;
  const x = dx*k, y = dy*k;
  joyKnob.style.transform = `translate(${x}px, ${y}px) translate(-50%, -50%)`;

  // decide direction using deadzone
  const dz = 10;
  if(dist < dz) return;

  if(Math.abs(x) > Math.abs(y)){
    setNextDir(x>0 ? 1 : -1, 0);
  } else {
    setNextDir(0, y>0 ? 1 : -1);
  }
}

function joyReset(){
  joyKnob.style.transform = "translate(-50%, -50%)";
}

joystick.addEventListener("pointerdown", (e) => {
  joyActive = true;
  joystick.setPointerCapture(e.pointerId);
  const rect = joystick.getBoundingClientRect();
  joyCenter.x = rect.left + rect.width/2;
  joyCenter.y = rect.top + rect.height/2;
  joySetKnob(e.clientX - joyCenter.x, e.clientY - joyCenter.y);
  e.preventDefault();
}, { passive:false });

joystick.addEventListener("pointermove", (e) => {
  if(!joyActive) return;
  joySetKnob(e.clientX - joyCenter.x, e.clientY - joyCenter.y);
  e.preventDefault();
}, { passive:false });

joystick.addEventListener("pointerup", (e) => {
  joyActive = false;
  joyReset();
  e.preventDefault();
}, { passive:false });

joystick.addEventListener("pointercancel", () => {
  joyActive = false;
  joyReset();
}, { passive:true });

/* ---------------------------------------------------------
 *  Boot
 * --------------------------------------------------------- */
(function init(){
  // ensure wallet exists
  const w = loadWallet();
  hudCoins.textContent = String(w.coins|0);
  hudLevel.textContent = String(w.level|0);
  updateHUD();
  draw();
})();
})();
</script>
</body>
</html>
