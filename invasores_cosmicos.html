<!doctype html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Invasores C√≥smicos ¬∑ PLUS</title>

<style>
  :root{
    --bg1:#4a90e2;
    --bg2:#1a3c6e;
    --panel:#0f172af5;
    --muted:#cbd5f5;
    --text:#f9fafb;
    --accent:#38bdf8;
    --gold:#facc15;
    --violet:#a78bfa;
    --green:#22c55e;
    --red:#fb7185;
  }
  *{ box-sizing:border-box; margin:0; padding:0; font-family:"Lato", system-ui, -apple-system, BlinkMacSystemFont, sans-serif; }
  body{
    min-height:100vh;
    display:flex;
    align-items:center;
    justify-content:center;
    background:linear-gradient(var(--bg1), var(--bg2));
    color:var(--text);
    padding:16px;
  }
  .game-wrapper{
    width:100%;
    max-width:860px;
    background:var(--panel);
    border-radius:24px;
    box-shadow:0 14px 28px rgba(0,0,0,.35);
    padding:18px 18px 22px;
    display:flex;
    flex-direction:column;
    gap:12px;
    position:relative;
    overflow:hidden;
  }
  .game-header{
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:12px;
  }
  .game-header-left h1{
    font-size:18px;
    font-weight:900;
    letter-spacing:.2px;
  }
  .game-header-left p{
    font-size:13px;
    color:var(--muted);
    line-height:1.25;
    max-width:560px;
  }
  .game-header-right{
    display:flex;
    flex-direction:column;
    align-items:flex-end;
    gap:6px;
  }
  .btn-volver{
    border:none;
    border-radius:14px;
    padding:7px 12px;
    font-size:13px;
    font-weight:800;
    cursor:pointer;
    background:#e2e8f0;
    color:#0f172a;
    box-shadow:0 3px 0 #cbd5e1;
    transition:transform .12s ease, box-shadow .12s ease;
    user-select:none;
  }
  .btn-volver:hover{ transform:translateY(-1px); box-shadow:0 5px 0 #cbd5e1; }
  .btn-volver:active{ transform:translateY(2px); box-shadow:0 1px 0 #cbd5e1; }

  .hud{
    display:flex;
    gap:12px;
    font-size:13px;
    color:#e5e7eb;
    flex-wrap:wrap;
    justify-content:flex-end;
    align-items:center;
  }
  .hud span strong{ color:var(--gold); }

  .chip{
    display:inline-flex;
    align-items:center;
    gap:6px;
    padding:6px 10px;
    border-radius:999px;
    background:rgba(2,6,23,0.35);
    box-shadow:inset 0 0 0 1px rgba(148,163,184,0.18);
    font-size:12px;
    color:#e5e7eb;
  }
  .bar{
    width:120px;
    height:8px;
    border-radius:999px;
    background:rgba(148,163,184,0.18);
    overflow:hidden;
    box-shadow:inset 0 0 0 1px rgba(15,23,42,0.35);
  }
  .bar > i{
    display:block;
    height:100%;
    width:0%;
    background:linear-gradient(90deg, var(--accent), var(--violet));
    border-radius:999px;
    box-shadow:0 0 14px rgba(56,189,248,0.45);
  }

  .game-container{
    margin-top:6px;
    background:linear-gradient(#1d4ed8, #1e293b);
    border-radius:20px;
    padding:10px 10px 12px;
    box-shadow:inset 0 0 0 1px rgba(15,23,42,.4);
  }
  canvas{
    display:block;
    width:100%;
    max-width:860px;
    height:auto;
    border-radius:16px;
    background:#0b1224;
    touch-action:none;
  }
  .help{
    font-size:12px;
    color:var(--muted);
    margin-top:6px;
    display:flex;
    justify-content:space-between;
    align-items:center;
    gap:8px;
    flex-wrap:wrap;
  }
  .btn-restart, .btn-secondary{
    border:none;
    border-radius:14px;
    padding:7px 14px;
    font-size:12px;
    font-weight:900;
    cursor:pointer;
    color:var(--text);
    transition:transform .12s ease, box-shadow .12s ease, filter .12s ease;
    user-select:none;
  }
  .btn-restart{
    background:linear-gradient(135deg,#22c55e,#16a34a);
    box-shadow:0 3px 0 #15803d;
    display:none;
  }
  .btn-secondary{
    background:linear-gradient(135deg,#60a5fa,#2563eb);
    box-shadow:0 3px 0 #1e40af;
    display:inline-block;
  }
  .btn-power{
    background:linear-gradient(135deg,#a78bfa,#7c3aed);
    box-shadow:0 3px 0 #4c1d95;
  }
  .btn-restart:hover, .btn-secondary:hover{ transform:translateY(-1px); filter:brightness(1.03); }
  .btn-restart:active, .btn-secondary:active{ transform:translateY(2px); filter:brightness(0.98); }
</style>
</head>

<body>
  <div class="game-wrapper">
    <div class="game-header">
      <div class="game-header-left">
        <h1>Invasores C√≥smicos ¬∑ PLUS</h1>
        <p>Dispara, esquiva, recoge <b>monedas</b> y atrapa <b>poderes aleatorios</b>: Im√°n, Pulso y Dron. Pulso se activa con <b>Q</b> o bot√≥n.</p>
      </div>

      <div class="game-header-right">
        <button class="btn-volver" onclick="window.location.href='panel.html'">‚¨Ö Volver al panel</button>
        <div class="hud">
          <span>Puntaje: <strong id="hudScore">0</strong></span>
          <span>| Nivel: <strong id="hudLevel">1</strong></span>
          <span>| Vidas: <strong id="hudLives">3</strong></span>
          <span>| Oleada: <strong id="hudWave">1</strong></span>
          <span>| Monedas: <strong id="hudCoins">0</strong></span>

          <span class="chip" title="Energ√≠a del escudo (se recarga con monedas)">
            Escudo
            <span class="bar"><i id="hudShieldBar" style="width:0%"></i></span>
          </span>

          <span class="chip" title="Potencia actual por nivel">
            Poder: <strong id="hudPower">Base</strong>
          </span>

          <span class="chip" title="Power-ups aleatorios activos">
            Extra: <strong id="hudExtras">-</strong>
          </span>
        </div>
      </div>
    </div>

    <div class="game-container">
      <canvas id="gameCanvas" width="840" height="520"></canvas>
      <div class="help">
        <span>PC: ‚Üê ‚Üí ‚Üë ‚Üì mover, Espacio disparar, Q Pulso, P pausa. M√≥vil: desliza (X/Y) y toca para disparar.</span>
        <div style="display:flex; gap:8px; align-items:center;">
          <button id="btnPause" class="btn-secondary">‚è∏ Pausa</button>
          <button id="btnPower" class="btn-secondary btn-power">‚ö° Pulso (Q)</button>
          <button id="btnRestart" class="btn-restart">üîÑ Reintentar</button>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
"use strict";

/* ---------------------------------------------------------
 *  DOM / CANVAS
 * --------------------------------------------------------- */
const canvas = document.getElementById("gameCanvas");
const ctx = canvas.getContext("2d", { alpha:true });

const hudScore = document.getElementById("hudScore");
const hudLevel = document.getElementById("hudLevel");
const hudLives = document.getElementById("hudLives");
const hudWave  = document.getElementById("hudWave");
const hudCoins = document.getElementById("hudCoins");
const hudPower = document.getElementById("hudPower");
const hudShieldBar = document.getElementById("hudShieldBar");
const hudExtras = document.getElementById("hudExtras");

const btnRestart = document.getElementById("btnRestart");
const btnPause   = document.getElementById("btnPause");
const btnPower   = document.getElementById("btnPower");

const W = canvas.width;
const H = canvas.height;

/* ---------------------------------------------------------
 *  CONFIG
 * --------------------------------------------------------- */
const SCORE_INVADER = 12;
const SCORE_UFO = 80;

const BASE_INVADER_SPEED = 0.55;
const BASE_DESCEND = 18;

const PLAYER_SPEED = 6.4;
const PLAYER_SPEED_Y = 4.2;  // ‚úÖ NUEVO: velocidad vertical (adelante/atr√°s)

const BULLET_SPEED = 11.0;
const ENEMY_BULLET_SPEED = 6.8;

const BASE_COOLDOWN_MS = 240;
const MIN_COOLDOWN_MS  = 110;

const ENEMY_FIRE_BASE_MS = 980;

const SHIELD_COUNT = 3;
const SHIELD_HP = 14;

const BANNER_FRAMES = 110;

// Monedas
const COIN_FALL_SPEED = 2.7;
const COIN_INTERVAL_MS = 1700;
const COIN_LIFETIME_MS = 8200;
const COIN_VALUE = 1;

// Escudo (nivel 4+)
const SHIELD_MAX = 100;
const SHIELD_RECHARGE_PER_COIN = 6;
const SHIELD_DRAIN_PER_HIT = 35;

// Power-ups aleatorios
const POWER_FALL_SPEED = 2.4;
const POWER_INTERVAL_MS = 5200;
const POWER_LIFETIME_MS = 9000;
const POWER_DROP_ON_KILL_CHANCE = 0.07;
const POWER_DROP_ON_UFO_CHANCE  = 0.55;

// Magnet
const MAGNET_RANGE = 150;
const MAGNET_MS = 6500;

// Drone
const DRONE_MS = 9000;
const DRONE_FIRE_MS = 420;

// Pulse
const PULSE_RADIUS = 140;
const PULSE_COOLDOWN_MS = 5200;
const PULSE_DAMAGE_CHANCE = 1.0;

/* ---------------------------------------------------------
 *  UTILS
 * --------------------------------------------------------- */
const clamp = (v,a,b) => Math.max(a, Math.min(b, v));
const rand = (a,b) => a + Math.random()*(b-a);

function roundedRectPath(g, x, y, w, h, r){
  const rr = Math.min(r, w/2, h/2);
  g.beginPath();
  g.moveTo(x+rr, y);
  g.lineTo(x+w-rr, y);
  g.quadraticCurveTo(x+w, y, x+w, y+rr);
  g.lineTo(x+w, y+h-rr);
  g.quadraticCurveTo(x+w, y+h, x+w-rr, y+h);
  g.lineTo(x+rr, y+h);
  g.quadraticCurveTo(x, y+h, x, y+h-rr);
  g.lineTo(x, y+rr);
  g.quadraticCurveTo(x, y, x+rr, y);
  g.closePath();
}

function aabb(ax,ay,aw,ah, bx,by,bw,bh){
  return ax < bx + bw && ax + aw > bx && ay < by + bh && ay + ah > by;
}

function dist2(x1,y1,x2,y2){
  const dx=x1-x2, dy=y1-y2;
  return dx*dx + dy*dy;
}

/* ---------------------------------------------------------
 *  AUDIO (FX)
 * --------------------------------------------------------- */
let fxCtx = null;
function getFxCtx(){
  if(!fxCtx){
    const AC = window.AudioContext || window.webkitAudioContext;
    if(AC) fxCtx = new AC();
  }
  return fxCtx;
}
function fxBeep(steps, dur = 0.28, vol = 0.18, type = "square"){
  const ac = getFxCtx();
  if(!ac) return;
  if(ac.state === "suspended") ac.resume();

  const now = ac.currentTime;
  const osc = ac.createOscillator();
  const gain = ac.createGain();

  osc.type = type;
  gain.gain.setValueAtTime(vol, now);

  osc.connect(gain);
  gain.connect(ac.destination);

  for(const s of steps){
    osc.frequency.setValueAtTime(s.freq, now + s.time);
  }

  gain.gain.exponentialRampToValueAtTime(0.001, now + dur);
  osc.start(now);
  osc.stop(now + dur + 0.02);
}
function playFx(kind){
  switch(kind){
    case "shoot":
      fxBeep([{time:0.00,freq:820},{time:0.06,freq:520}], 0.12, 0.14, "square"); break;
    case "coin":
      fxBeep([{time:0.00,freq:900},{time:0.05,freq:1100},{time:0.10,freq:1350}], 0.18, 0.18, "triangle"); break;
    case "hit":
      fxBeep([{time:0.00,freq:420},{time:0.05,freq:260},{time:0.10,freq:180}], 0.18, 0.18); break;
    case "boom":
      fxBeep([{time:0.00,freq:230},{time:0.06,freq:150},{time:0.12,freq:95}], 0.22, 0.20, "sawtooth"); break;
    case "levelup":
      fxBeep([{time:0.00,freq:620},{time:0.06,freq:860},{time:0.12,freq:1120}], 0.26, 0.18); break;
    case "shield":
      fxBeep([{time:0.00,freq:740},{time:0.08,freq:980},{time:0.16,freq:880}], 0.22, 0.15, "sine"); break;
    case "lose":
      fxBeep([{time:0.00,freq:520},{time:0.12,freq:220},{time:0.24,freq:110}], 0.36, 0.20); break;
    case "ufo":
      fxBeep([{time:0.00,freq:880},{time:0.10,freq:980},{time:0.20,freq:920}], 0.30, 0.13, "triangle"); break;
    case "power":
      fxBeep([{time:0.00,freq:520},{time:0.06,freq:780},{time:0.12,freq:1040}], 0.20, 0.16, "triangle"); break;
    case "pulse":
      fxBeep([{time:0.00,freq:520},{time:0.08,freq:260},{time:0.16,freq:880}], 0.26, 0.18, "sawtooth"); break;
    default:
      fxBeep([{time:0.00,freq:520},{time:0.07,freq:650}], 0.18, 0.12);
  }
}

/* ---------------------------------------------------------
 *  PARTICLES
 * --------------------------------------------------------- */
const particles = [];
function emitParticles(px, py, count, cfg = {}){
  const {
    minVx=-2.6, maxVx=2.6,
    minVy=-3.2, maxVy=-0.7,
    minR=1.2, maxR=3.2,
    life=36,
    gravity=0.11,
    drag=0.985,
    color="#fde047",
    glow=true
  } = cfg;

  for(let i=0;i<count;i++){
    particles.push({
      x:px, y:py,
      vx:rand(minVx,maxVx),
      vy:rand(minVy,maxVy),
      r:rand(minR,maxR),
      life:life + Math.floor(rand(-10, 12)),
      t:0,
      g:gravity,
      d:drag,
      color,
      glow
    });
  }
}
function updateParticles(){
  for(let i=particles.length-1;i>=0;i--){
    const p=particles[i];
    p.t++;
    p.vx *= p.d;
    p.vy = (p.vy + p.g) * p.d;
    p.x += p.vx;
    p.y += p.vy;
    if(p.t >= p.life) particles.splice(i,1);
  }
}
function drawParticles(){
  for(const p of particles){
    const a = 1 - (p.t / p.life);
    ctx.globalAlpha = a;
    if(p.glow){ ctx.shadowColor = p.color; ctx.shadowBlur = 14 * a; }
    else ctx.shadowBlur = 0;
    ctx.fillStyle = p.color;
    ctx.beginPath();
    ctx.arc(p.x, p.y, p.r, 0, Math.PI*2);
    ctx.fill();
    ctx.shadowBlur = 0;
  }
  ctx.globalAlpha = 1;
}

/* ---------------------------------------------------------
 *  STATE
 * --------------------------------------------------------- */
const state = {
  frame: 0,
  score: 0,
  level: 1,
  wave: 1,
  lives: 3,
  coins: 0,

  playing: true,
  paused: false,

  banner: 0,
  shake: 0,
  swoosh: 0,
  swooshFlash: 0,

  invaderDir: 1,
  invaderSpeed: BASE_INVADER_SPEED,
  descend: BASE_DESCEND,

  lastShotAt: 0,
  enemyFireAt: 0,

  ufo: null,
  ufoAt: 0,

  shieldEnergy: 0,
  coinDropAt: 0,
  chroma: 0,

  powerDropAt: 0,
  magnetUntil: 0,
  droneUntil: 0,
  droneFireAt: 0,
  pulseReadyAt: 0,
  pulseCharges: 0,
};

/* ---------------------------------------------------------
 *  ENTITIES
 * --------------------------------------------------------- */
const player = { x: W/2, y: H-58, w: 46, h: 18, vx:0 };

const bullets = [];
const eBullets = [];
let invaders = [];
let shields = [];
const coins = [];
const powers = [];

// ‚úÖ NUEVO: keys incluye UP/DOWN
const keys = { left:false, right:false, up:false, down:false, shoot:false };

/* ---------------------------------------------------------
 *  POWER / PROGRESSION
 * --------------------------------------------------------- */
function currentPower(){
  if(state.level >= 5) return "Plasma";
  if(state.level >= 4) return "Escudo";
  if(state.level >= 3) return "Triple";
  if(state.level >= 2) return "Doble";
  return "Base";
}

function currentCooldownMs(){
  const lvlBoost = (state.level-1) * 18;
  const coinBoost = clamp(Math.floor(state.coins/12)*6, 0, 50);
  return clamp(BASE_COOLDOWN_MS - lvlBoost - coinBoost, MIN_COOLDOWN_MS, BASE_COOLDOWN_MS);
}

function extrasLabel(){
  const now = performance.now();
  const list = [];
  if(now < state.magnetUntil) list.push("IM√ÅN");
  if(now < state.droneUntil) list.push("DRON");
  if(state.pulseCharges > 0) list.push("PULSO x" + state.pulseCharges);
  return list.length ? list.join(" ¬∑ ") : "-";
}

function applyCoinReward(n=1, px=player.x, py=player.y){
  state.coins += n;
  if(state.level >= 4){
    state.shieldEnergy = clamp(state.shieldEnergy + n*SHIELD_RECHARGE_PER_COIN, 0, SHIELD_MAX);
  }
  hudCoins.textContent = String(state.coins);
  hudShieldBar.style.width = `${Math.round((state.shieldEnergy/SHIELD_MAX)*100)}%`;
  playFx("coin");
  emitParticles(px, py, 16, { color:"#fde047", minVy:-3.6, maxVy:-1.2, glow:true, gravity:0.10 });
  state.chroma = Math.max(state.chroma, 10);
}

function evolveIfNeeded(){
  const newLevel = 1 + Math.floor((state.wave-1)/2);
  if(newLevel > state.level){
    state.level = newLevel;
    state.banner = BANNER_FRAMES;
    state.swoosh = 28;
    state.swooshFlash = 12;
    state.shake = Math.max(state.shake, 14);
    playFx("levelup");
  }
  hudLevel.textContent = String(state.level);
  hudPower.textContent = currentPower();
}

function syncHud(){
  hudScore.textContent = String(state.score);
  hudLevel.textContent = String(state.level);
  hudLives.textContent = String(state.lives);
  hudWave.textContent  = String(state.wave);
  hudCoins.textContent = String(state.coins);
  hudPower.textContent = currentPower();
  hudShieldBar.style.width = `${Math.round((state.shieldEnergy/SHIELD_MAX)*100)}%`;
  hudExtras.textContent = extrasLabel();
}

/* ---------------------------------------------------------
 *  INIT / RESET
 * --------------------------------------------------------- */
function buildShields(){
  shields = [];
  const margin = 110;
  const gap = (W - 2*margin) / (SHIELD_COUNT-1);
  for(let i=0;i<SHIELD_COUNT;i++){
    const x = margin + i*gap - 44;
    const y = H - 140;
    shields.push({ x, y, w:88, h:38, hp:SHIELD_HP });
  }
}

function buildInvaders(){
  invaders = [];
  const rows = clamp(4 + Math.floor((state.wave-1)*0.5), 4, 7);
  const cols = 10;

  const iw = 32;
  const ih = 22;
  const gapX = 12;
  const gapY = 12;

  const totalW = cols*iw + (cols-1)*gapX;
  const startX = (W - totalW)/2;
  const startY = 70;

  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      invaders.push({ x:startX + c*(iw+gapX), y:startY + r*(ih+gapY), w:iw, h:ih, row:r, col:c });
    }
  }

  state.invaderDir = 1;
  state.invaderSpeed = BASE_INVADER_SPEED + (state.level-1)*0.16 + (state.wave-1)*0.05;
  state.descend = BASE_DESCEND + (state.level-1)*2;
}

function resetRound(keepProgress=true){
  bullets.length = 0;
  eBullets.length = 0;
  particles.length = 0;
  coins.length = 0;
  powers.length = 0;

  player.x = W/2;
  player.y = H-58;
  player.vx = 0;

  buildShields();
  buildInvaders();

  const now = performance.now();
  state.enemyFireAt = now + 600;
  state.ufo = null;
  state.ufoAt = now + rand(6500, 11000);
  state.coinDropAt = now + rand(600, 1200);
  state.powerDropAt = now + rand(2200, 4200);

  state.droneFireAt = now + 250;

  if(!keepProgress){
    state.score = 0;
    state.level = 1;
    state.wave  = 1;
    state.lives = 3;
    state.coins = 0;
    state.shieldEnergy = 0;
    state.playing = true;
    state.paused = false;
    state.banner = 0;
    state.shake  = 0;
    state.swoosh = 0;
    state.swooshFlash = 0;
    state.chroma = 0;

    state.magnetUntil = 0;
    state.droneUntil = 0;
    state.pulseReadyAt = 0;
    state.pulseCharges = 0;
  }

  btnRestart.style.display = "none";
  btnPause.style.display = "inline-block";
  btnPause.textContent = "‚è∏ Pausa";
  syncHud();
}

function resetGame(){
  state.score = 0;
  state.level = 1;
  state.wave  = 1;
  state.lives = 3;
  state.coins = 0;
  state.shieldEnergy = 0;

  state.playing = true;
  state.paused = false;
  state.banner = 0;
  state.shake  = 0;
  state.swoosh = 0;
  state.swooshFlash = 0;
  state.chroma = 0;

  state.magnetUntil = 0;
  state.droneUntil = 0;
  state.pulseReadyAt = 0;
  state.pulseCharges = 0;

  resetRound(true);
}

function gameOver(){
  state.playing = false;
  state.paused = false;
  state.shake = 18;
  btnRestart.style.display = "inline-block";
  btnPause.style.display = "none";
  playFx("lose");
}

/* ---------------------------------------------------------
 *  INPUT
 * --------------------------------------------------------- */
document.addEventListener("keydown", (e) => {
  if(e.code === "ArrowLeft"){ e.preventDefault(); keys.left=true; }
  if(e.code === "ArrowRight"){ e.preventDefault(); keys.right=true; }
  if(e.code === "ArrowUp"){ e.preventDefault(); keys.up=true; }       // ‚úÖ NUEVO
  if(e.code === "ArrowDown"){ e.preventDefault(); keys.down=true; }   // ‚úÖ NUEVO

  if(e.code === "Space"){ e.preventDefault(); keys.shoot=true; }
  if(e.code === "KeyP"){ e.preventDefault(); togglePause(); }
  if(e.code === "KeyQ"){ e.preventDefault(); tryPulse(); }
  if(!state.playing && (e.code === "Enter" || e.code === "KeyR")) resetGame();
});
document.addEventListener("keyup", (e) => {
  if(e.code === "ArrowLeft"){ keys.left=false; }
  if(e.code === "ArrowRight"){ keys.right=false; }
  if(e.code === "ArrowUp"){ keys.up=false; }         // ‚úÖ NUEVO
  if(e.code === "ArrowDown"){ keys.down=false; }     // ‚úÖ NUEVO
  if(e.code === "Space"){ keys.shoot=false; }
});

// Touch swipe
let touch = null;

canvas.addEventListener("touchstart", (e) => {
  e.preventDefault();
  const t = e.touches[0];
  touch = { x:t.clientX, y:t.clientY, px:t.clientX, py:t.clientY }; // ‚úÖ NUEVO: py
  if(state.playing && !state.paused) tryShoot();
}, { passive:false });

canvas.addEventListener("touchmove", (e) => {
  e.preventDefault();
  if(!touch) return;

  const t = e.touches[0];
  const dx = t.clientX - touch.px;
  const dy = t.clientY - touch.py;
  touch.px = t.clientX;
  touch.py = t.clientY;

  // ‚úÖ NUEVO: mover en X y Y
  player.x += dx * 1.2;
  player.y += dy * 0.9;

  // l√≠mites X
  player.x = clamp(player.x, 24, W-24);

  // l√≠mites Y (adelante/atr√°s)
  const minY = H * 0.55;
  const maxY = H - 36;
  player.y = clamp(player.y, minY, maxY);
}, { passive:false });

canvas.addEventListener("touchend", (e) => { e.preventDefault(); touch=null; }, { passive:false });

btnRestart.addEventListener("click", resetGame);
btnPause.addEventListener("click", () => togglePause());
btnPower.addEventListener("click", () => tryPulse());

function togglePause(){
  if(!state.playing) return;
  state.paused = !state.paused;
  btnPause.textContent = state.paused ? "‚ñ∂ Reanudar" : "‚è∏ Pausa";
}

/* ---------------------------------------------------------
 *  COINS
 * --------------------------------------------------------- */
function spawnCoin(x=null, y=null){
  coins.push({
    x: (x !== null) ? x : rand(40, W-40),
    y: (y !== null) ? y : -18,
    r: 11,
    vy: COIN_FALL_SPEED + (state.level-1)*0.12,
    bornAt: performance.now(),
    spin: rand(0, Math.PI*2),
    glow: rand(0.35, 0.85)
  });
}

function updateCoins(){
  if(state.paused) return;
  const now = performance.now();

  if(now > state.coinDropAt){
    spawnCoin(null, -16);
    state.coinDropAt = now + COIN_INTERVAL_MS * rand(0.78, 1.18);
  }

  const magnetOn = now < state.magnetUntil;

  for(let i=coins.length-1;i>=0;i--){
    const c = coins[i];

    if(magnetOn){
      const d2 = dist2(c.x,c.y, player.x, player.y);
      if(d2 < MAGNET_RANGE*MAGNET_RANGE){
        const d = Math.max(12, Math.sqrt(d2));
        const ax = (player.x - c.x) / d;
        const ay = (player.y - c.y) / d;
        c.x += ax * 4.8;
        c.y += ay * 4.8;
      }
    }

    c.y += c.vy;
    c.spin += 0.10 + (state.level*0.01);

    if(now - c.bornAt > COIN_LIFETIME_MS || c.y > H + 30){
      coins.splice(i,1);
      continue;
    }

    const px = player.x - player.w/2;
    const py = player.y - player.h/2;
    if(aabb(c.x-c.r, c.y-c.r, c.r*2, c.r*2, px, py, player.w, player.h)){
      coins.splice(i,1);
      applyCoinReward(COIN_VALUE, c.x, c.y);
      syncHud();
    }
  }
}

/* ---------------------------------------------------------
 *  POWERS (RANDOM)
 * --------------------------------------------------------- */
const POWER_TYPES = ["MAGNET", "PULSE", "DRONE"];

function pickRandomPower(){
  return POWER_TYPES[Math.floor(Math.random()*POWER_TYPES.length)];
}

function spawnPower(kind=null, x=null, y=null){
  const k = kind || pickRandomPower();
  powers.push({
    kind: k,
    x: (x !== null) ? x : rand(60, W-60),
    y: (y !== null) ? y : -20,
    r: 13,
    vy: POWER_FALL_SPEED + (state.level-1)*0.10,
    bornAt: performance.now(),
    spin: rand(0, Math.PI*2)
  });
}

function updatePowers(){
  if(state.paused) return;
  const now = performance.now();

  if(now > state.powerDropAt){
    spawnPower(null, null, -20);
    state.powerDropAt = now + POWER_INTERVAL_MS * rand(0.75, 1.25);
  }

  for(let i=powers.length-1;i>=0;i--){
    const p = powers[i];
    p.y += p.vy;
    p.spin += 0.10;

    if(now - p.bornAt > POWER_LIFETIME_MS || p.y > H + 40){
      powers.splice(i,1);
      continue;
    }

    const px = player.x - player.w/2;
    const py = player.y - player.h/2;
    if(aabb(p.x-p.r, p.y-p.r, p.r*2, p.r*2, px, py, player.w, player.h)){
      powers.splice(i,1);
      activatePower(p.kind, p.x, p.y);
      syncHud();
    }
  }
}

function activatePower(kind, x, y){
  const now = performance.now();
  playFx("power");
  state.chroma = Math.max(state.chroma, 12);
  emitParticles(x, y, 22, { color:"#a78bfa", minVy:-3.6, maxVy:-1.2, glow:true, gravity:0.10 });

  if(kind === "MAGNET"){
    state.magnetUntil = Math.max(state.magnetUntil, now) + MAGNET_MS;
    emitParticles(player.x, player.y-10, 18, { color:"#fde047", minVy:-3.6, maxVy:-1.0, glow:true, gravity:0.09 });
  }
  if(kind === "DRONE"){
    state.droneUntil = Math.max(state.droneUntil, now) + DRONE_MS;
    state.droneFireAt = now + 120;
    emitParticles(player.x, player.y-18, 18, { color:"#38bdf8", minVy:-3.4, maxVy:-1.0, glow:true, gravity:0.09 });
  }
  if(kind === "PULSE"){
    state.pulseCharges = clamp(state.pulseCharges + 1, 0, 3);
  }
}

function tryPulse(){
  if(!state.playing || state.paused) return;
  const now = performance.now();
  if(state.pulseCharges <= 0) return;
  if(now < state.pulseReadyAt) return;

  state.pulseCharges--;
  state.pulseReadyAt = now + PULSE_COOLDOWN_MS;

  playFx("pulse");
  state.shake = Math.max(state.shake, 12);
  state.chroma = Math.max(state.chroma, 14);

  eBullets.length = 0;

  const px = player.x, py = player.y-20;
  const r2 = PULSE_RADIUS*PULSE_RADIUS;
  for(let i=invaders.length-1;i>=0;i--){
    const inv = invaders[i];
    const cx = inv.x + inv.w/2;
    const cy = inv.y + inv.h/2;
    if(dist2(cx,cy, px,py) <= r2 && Math.random() <= PULSE_DAMAGE_CHANCE){
      invaders.splice(i,1);
      state.score += SCORE_INVADER + Math.floor(state.level*1.2);
      emitParticles(cx, cy, 16, { color:"#38bdf8", minVy:-3.2, maxVy:-1.0, glow:true });
      if(Math.random() < 0.18) spawnCoin(cx, cy);
      if(Math.random() < 0.06) spawnPower(null, cx, cy);
    }
  }

  emitPulseRing(px, py, PULSE_RADIUS);
  syncHud();
}

const pulseRings = [];
function emitPulseRing(x,y,maxR){ pulseRings.push({ x, y, r:8, max:maxR, t:0 }); }
function updatePulseRings(){
  for(let i=pulseRings.length-1;i>=0;i--){
    const pr = pulseRings[i];
    pr.t++;
    pr.r += 10;
    if(pr.r >= pr.max) pulseRings.splice(i,1);
  }
}
function drawPulseRings(){
  for(const pr of pulseRings){
    const a = 1 - (pr.r / pr.max);
    ctx.save();
    ctx.globalAlpha = 0.28 * a;
    ctx.shadowColor = "#a78bfa";
    ctx.shadowBlur = 18 * a;
    ctx.strokeStyle = "#a78bfa";
    ctx.lineWidth = 4;
    ctx.beginPath();
    ctx.arc(pr.x, pr.y, pr.r, 0, Math.PI*2);
    ctx.stroke();
    ctx.restore();
  }
}

/* ---------------------------------------------------------
 *  SHOOTING + DRONE
 * --------------------------------------------------------- */
function tryShoot(){
  if(!state.playing || state.paused) return;
  const now = performance.now();
  const cd = currentCooldownMs();
  if(now - state.lastShotAt < cd) return;
  state.lastShotAt = now;

  const power = currentPower();
  const base = { y: player.y - 16, w: 4, h: 12, vy: -BULLET_SPEED, pierce: (power === "Plasma") };

  if(power === "Doble"){
    bullets.push({ x: player.x - 10, ...base });
    bullets.push({ x: player.x + 6,  ...base });
  } else if(power === "Triple" || power === "Escudo"){
    bullets.push({ x: player.x - 12, ...base, vx:-0.6 });
    bullets.push({ x: player.x - 2,  ...base, vx: 0.0 });
    bullets.push({ x: player.x + 8,  ...base, vx:+0.6 });
  } else if(power === "Plasma"){
    bullets.push({ x: player.x - 6, ...base, w:6, h:16, vx:0 });
    bullets.push({ x: player.x + 2, ...base, w:6, h:16, vx:0 });
  } else {
    bullets.push({ x: player.x - 2, ...base });
  }

  playFx("shoot");
  emitParticles(player.x, player.y, 12, { color:"#38bdf8", minVy:-3.0, maxVy:-1.0, gravity:0.08, glow:true });
  state.chroma = Math.max(state.chroma, 6);
}

function updateDrone(){
  if(state.paused) return;
  const now = performance.now();
  if(now >= state.droneUntil) return;

  if(now > state.droneFireAt){
    state.droneFireAt = now + DRONE_FIRE_MS * rand(0.85, 1.15);
    bullets.push({
      x: (player.x + 18) - 2,
      y: (player.y - 28),
      w: 4, h: 12,
      vy: -BULLET_SPEED - 1.2,
      pierce: false,
      vx: 0
    });
    emitParticles(player.x+18, player.y-26, 8, { color:"#93c5fd", minVy:-3.4, maxVy:-1.0, glow:true, gravity:0.09 });
  }
}

/* ---------------------------------------------------------
 *  ENEMIES
 * --------------------------------------------------------- */
function pickShooterInvader(){
  if(invaders.length === 0) return null;
  const byCol = new Map();
  for(const inv of invaders){
    const k = inv.col;
    const cur = byCol.get(k);
    if(!cur || inv.y > cur.y) byCol.set(k, inv);
  }
  const candidates = [...byCol.values()];
  if(candidates.length === 0) return null;
  return candidates[Math.floor(Math.random()*candidates.length)];
}

function updateEnemyFire(){
  if(state.paused) return;

  const now = performance.now();
  const fireEvery = Math.max(260, ENEMY_FIRE_BASE_MS - state.level*78 - state.wave*30);
  if(now < state.enemyFireAt) return;
  state.enemyFireAt = now + fireEvery * rand(0.62, 1.12);

  const shooter = pickShooterInvader();
  if(!shooter) return;

  eBullets.push({ x: shooter.x + shooter.w/2 - 2, y: shooter.y + shooter.h + 4, w: 4, h: 12, vy: ENEMY_BULLET_SPEED + state.level*0.35 });
  playFx("hit");
}

function updateUfo(){
  if(state.paused) return;

  const now = performance.now();
  if(!state.ufo && now > state.ufoAt && Math.random() < 0.80){
    const dir = Math.random() < 0.5 ? 1 : -1;
    state.ufo = { x: dir === 1 ? -60 : W+60, y: 44, w: 54, h: 18, vx: dir * (2.2 + state.level*0.22) };
    playFx("ufo");
  }

  if(state.ufo){
    state.ufo.x += state.ufo.vx;
    if(state.ufo.x < -90 || state.ufo.x > W+90){
      state.ufo = null;
      state.ufoAt = now + rand(7000, 12000);
    }
  }
}

function updateInvaders(){
  if(state.paused) return;
  if(invaders.length === 0) return;

  const aliveFactor = clamp(1.0 + (1 - invaders.length/60) * 1.8, 1, 2.9);
  const vx = state.invaderDir * state.invaderSpeed * aliveFactor;

  let minX = Infinity, maxX = -Infinity, maxY = -Infinity;
  for(const inv of invaders){
    inv.x += vx;
    minX = Math.min(minX, inv.x);
    maxX = Math.max(maxX, inv.x + inv.w);
    maxY = Math.max(maxY, inv.y + inv.h);
  }

  const hitLeft  = minX < 30;
  const hitRight = maxX > W - 30;

  if(hitLeft || hitRight){
    state.invaderDir *= -1;
    for(const inv of invaders) inv.y += state.descend;
    state.shake = Math.max(state.shake, 8);
    playFx("hit");
    state.chroma = Math.max(state.chroma, 8);
  }

  // ‚úÖ Nota: mantenemos condici√≥n de ‚Äúpierde si llegan muy abajo‚Äù
  // aunque el jugador suba un poco, la oleada sigue siendo peligrosa.
  if(maxY > player.y - 24){
    state.lives--;
    hudLives.textContent = String(state.lives);
    state.shake = 18;
    playFx("boom");
    if(state.lives <= 0) gameOver();
    else resetRound(true);
  }
}

/* ---------------------------------------------------------
 *  PLAYER + BULLETS
 * --------------------------------------------------------- */
function updatePlayer(){
  if(state.paused) return;

  let ax = 0;
  let ay = 0;

  if(keys.left)  ax -= 1;
  if(keys.right) ax += 1;
  if(keys.up)    ay -= 1;  // ‚úÖ NUEVO
  if(keys.down)  ay += 1;  // ‚úÖ NUEVO

  // mover X/Y
  player.x += ax * PLAYER_SPEED;
  player.y += ay * PLAYER_SPEED_Y;

  // l√≠mites X
  player.x = clamp(player.x, 24, W - 24);

  // ‚úÖ l√≠mites Y: no puede ‚Äúsubirse‚Äù demasiado ni bajar infinito
  const minY = H * 0.55;  // hasta d√≥nde puede avanzar (subir)
  const maxY = H - 36;    // hasta d√≥nde puede retroceder (bajar)
  player.y = clamp(player.y, minY, maxY);

  if(keys.shoot) tryShoot();
}

function updateBullets(){
  if(state.paused) return;

  for(let i=bullets.length-1;i>=0;i--){
    const b = bullets[i];
    b.y += b.vy;
    if(b.vx) b.x += b.vx * 2.2;
    if(b.y < -50) bullets.splice(i,1);
  }

  for(let i=eBullets.length-1;i>=0;i--){
    const b = eBullets[i];
    b.y += b.vy;
    if(b.y > H+60) eBullets.splice(i,1);
  }
}

/* ---------------------------------------------------------
 *  COLLISIONS / DAMAGE
 * --------------------------------------------------------- */
function damageShieldAt(sh, hitX, hitY){
  if(sh.hp <= 0) return;
  sh.hp--;
  emitParticles(hitX, hitY, 12, { color:"#a78bfa", minVy:-3.0, maxVy:-0.9, gravity:0.10, glow:true });
  if(sh.hp <= 0){
    emitParticles(sh.x + sh.w/2, sh.y + sh.h/2, 26, { color:"#38bdf8", minVy:-3.4, maxVy:-1.1, glow:true });
    playFx("boom");
  } else playFx("hit");
}

function hitPlayer(){
  if(state.level >= 4 && state.shieldEnergy > 0){
    state.shieldEnergy = clamp(state.shieldEnergy - SHIELD_DRAIN_PER_HIT, 0, SHIELD_MAX);
    hudShieldBar.style.width = `${Math.round((state.shieldEnergy/SHIELD_MAX)*100)}%`;
    playFx("shield");
    emitParticles(player.x, player.y-6, 20, { color:"#38bdf8", minVy:-3.4, maxVy:-1.2, glow:true, gravity:0.09 });
    state.shake = Math.max(state.shake, 10);
    state.chroma = Math.max(state.chroma, 10);
    return;
  }

  state.lives--;
  hudLives.textContent = String(state.lives);
  state.shake = 18;
  state.chroma = Math.max(state.chroma, 14);
  emitParticles(player.x, player.y, 30, { color:"#fde047", minVy:-3.6, maxVy:-1.0, glow:true });
  playFx("lose");

  if(state.lives <= 0) gameOver();
  else resetRound(true);
}

function handleCollisions(){
  if(state.paused) return;

  // player bullets
  for(let i=bullets.length-1;i>=0;i--){
    const b = bullets[i];

    // UFO
    if(state.ufo && aabb(b.x,b.y,b.w,b.h, state.ufo.x,state.ufo.y,state.ufo.w,state.ufo.h)){
      bullets.splice(i,1);
      state.score += SCORE_UFO;
      hudScore.textContent = String(state.score);
      state.shake = Math.max(state.shake, 10);
      state.chroma = Math.max(state.chroma, 12);

      emitParticles(state.ufo.x + state.ufo.w/2, state.ufo.y + state.ufo.h/2, 30, { color:"#fde047", minVy:-3.8, maxVy:-1.2, glow:true });
      spawnCoin(state.ufo.x + state.ufo.w/2, state.ufo.y + state.ufo.h/2);

      if(Math.random() < POWER_DROP_ON_UFO_CHANCE){
        spawnPower(null, state.ufo.x + state.ufo.w/2, state.ufo.y + state.ufo.h/2);
      }

      state.ufo = null;
      state.ufoAt = performance.now() + rand(8000, 13000);
      playFx("levelup");
      continue;
    }

    // invaders
    let consumed = false;
    for(let j=invaders.length-1;j>=0;j--){
      const inv = invaders[j];
      if(aabb(b.x,b.y,b.w,b.h, inv.x,inv.y,inv.w,inv.h)){
        invaders.splice(j,1);
        state.score += SCORE_INVADER + Math.floor(state.level*1.2);
        hudScore.textContent = String(state.score);

        state.shake = Math.max(state.shake, 6);
        state.chroma = Math.max(state.chroma, 8);

        const cx = inv.x + inv.w/2;
        const cy = inv.y + inv.h/2;
        emitParticles(cx, cy, 18, { color:"#38bdf8", minVy:-3.2, maxVy:-1.0, glow:true });
        playFx("boom");

        if(Math.random() < 0.28) spawnCoin(cx, cy);
        if(Math.random() < POWER_DROP_ON_KILL_CHANCE) spawnPower(null, cx, cy);

        if(!b.pierce){
          bullets.splice(i,1);
          consumed = true;
        }
        break;
      }
    }
    if(consumed) continue;

    // shields
    for(const sh of shields){
      if(sh.hp <= 0) continue;
      if(aabb(b.x,b.y,b.w,b.h, sh.x,sh.y,sh.w,sh.h)){
        bullets.splice(i,1);
        damageShieldAt(sh, b.x, b.y);
        break;
      }
    }
  }

  // enemy bullets
  for(let i=eBullets.length-1;i>=0;i--){
    const b = eBullets[i];

    if(aabb(b.x,b.y,b.w,b.h, player.x-player.w/2, player.y-player.h/2, player.w, player.h)){
      eBullets.splice(i,1);
      hitPlayer();
      continue;
    }

    for(const sh of shields){
      if(sh.hp <= 0) continue;
      if(aabb(b.x,b.y,b.w,b.h, sh.x,sh.y,sh.w,sh.h)){
        eBullets.splice(i,1);
        damageShieldAt(sh, b.x, b.y);
        break;
      }
    }
  }

  // win wave
  if(invaders.length === 0 && state.playing){
    state.wave++;
    hudWave.textContent = String(state.wave);

    applyCoinReward(3, W/2, 110);
    evolveIfNeeded();
    resetRound(true);
  }
}

/* ---------------------------------------------------------
 *  FX / BACKGROUND (simple)
 * --------------------------------------------------------- */
const stars1 = Array.from({length:70}, ()=>({x:rand(0,W), y:rand(0,H), r:rand(0.8,1.8), s:rand(0.10,0.35)}));
const stars2 = Array.from({length:44}, ()=>({x:rand(0,W), y:rand(0,H), r:rand(1.2,2.4), s:rand(0.25,0.65)}));
const stars3 = Array.from({length:18}, ()=>({x:rand(0,W), y:rand(0,H), r:rand(1.8,3.0), s:rand(0.55,1.05)}));

function drawBackground(){
  const g = ctx.createLinearGradient(0, 0, 0, H);
  g.addColorStop(0, "#060b1a");
  g.addColorStop(0.55, "#020617");
  g.addColorStop(1, "#00030c");
  ctx.fillStyle = g;
  ctx.fillRect(0,0,W,H);

  function drawStarLayer(arr, col, alpha){
    ctx.save();
    ctx.fillStyle = col;
    ctx.globalAlpha = alpha;
    for(const s of arr){
      s.y += s.s;
      if(s.y > H+6){ s.y = -6; s.x = rand(0,W); }
      ctx.beginPath();
      ctx.arc(s.x, s.y, s.r, 0, Math.PI*2);
      ctx.fill();
    }
    ctx.restore();
  }
  drawStarLayer(stars1, "#e5e7eb", 0.35);
  drawStarLayer(stars2, "#93c5fd", 0.42);
  drawStarLayer(stars3, "#ffffff", 0.28);
}

function applyShake(){
  if(state.shake <= 0) return {x:0,y:0};
  const p = state.shake / 18;
  return { x:(Math.random()-0.5)*10*p, y:(Math.random()-0.5)*6*p };
}

/* ---------------------------------------------------------
 *  DRAW (minimal pero potente)
 * --------------------------------------------------------- */
function drawPlayer(){
  const x = player.x - player.w/2;
  const y = player.y - player.h/2;

  const body = ctx.createLinearGradient(x, y, x, y + player.h);
  body.addColorStop(0, "#4ade80");
  body.addColorStop(1, "#166534");
  roundedRectPath(ctx, x, y, player.w, player.h, 9);
  ctx.fillStyle = body;
  ctx.fill();

  const cabW = player.w*0.40;
  const cabH = player.h*0.72;
  const cabX = player.x - cabW/2;
  const cabY = y - cabH*0.42;

  const cab = ctx.createLinearGradient(cabX, cabY, cabX, cabY + cabH);
  cab.addColorStop(0, "rgba(56,189,248,0.98)");
  cab.addColorStop(1, "rgba(29,78,216,0.55)");
  roundedRectPath(ctx, cabX, cabY, cabW, cabH, 12);
  ctx.fillStyle = cab;
  ctx.fill();

  if(state.level >= 4 && state.shieldEnergy > 0){
    const a = clamp(state.shieldEnergy/SHIELD_MAX, 0, 1);
    ctx.save();
    ctx.globalAlpha = 0.10 + 0.18*a;
    ctx.shadowColor = "#38bdf8";
    ctx.shadowBlur = 26;
    ctx.strokeStyle = "rgba(56,189,248,0.85)";
    ctx.lineWidth = 2.0;
    ctx.beginPath();
    ctx.ellipse(player.x, player.y, player.w*0.80, player.h*1.75, 0, 0, Math.PI*2);
    ctx.stroke();
    ctx.restore();
  }

  const now = performance.now();
  if(now < state.droneUntil){
    const dx = player.x + 18;
    const dy = player.y - 28;
    const dg = ctx.createLinearGradient(dx-16, dy-10, dx-16, dy+10);
    dg.addColorStop(0, "#93c5fd");
    dg.addColorStop(1, "#1d4ed8");
    roundedRectPath(ctx, dx-16, dy-10, 32, 20, 10);
    ctx.fillStyle = dg;
    ctx.fill();
    ctx.fillStyle = "rgba(15,23,42,0.65)";
    ctx.font = "900 10px Lato";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("DR", dx, dy+0.5);
  }
}

function drawInvaders(){
  for(const inv of invaders){
    const g = ctx.createLinearGradient(inv.x, inv.y, inv.x, inv.y + inv.h);
    g.addColorStop(0, inv.row <= 1 ? "#38bdf8" : "#a78bfa");
    g.addColorStop(1, "#0f172a");
    roundedRectPath(ctx, inv.x, inv.y, inv.w, inv.h, 9);
    ctx.fillStyle = g;
    ctx.fill();

    ctx.fillStyle = "rgba(236,254,255,0.95)";
    ctx.beginPath();
    ctx.arc(inv.x + inv.w*0.35, inv.y + inv.h*0.45, 2.8, 0, Math.PI*2);
    ctx.arc(inv.x + inv.w*0.65, inv.y + inv.h*0.45, 2.8, 0, Math.PI*2);
    ctx.fill();
  }
}

function drawShields(){
  for(const sh of shields){
    if(sh.hp <= 0) continue;
    const t = sh.hp / SHIELD_HP;
    const alpha = 0.55 + 0.35*t;
    ctx.fillStyle = `rgba(56,189,248,${alpha})`;
    roundedRectPath(ctx, sh.x, sh.y, sh.w, sh.h, 14);
    ctx.fill();
  }
}

function drawBullets(){
  for(const b of bullets){
    ctx.fillStyle = b.pierce ? "#a78bfa" : "#38bdf8";
    roundedRectPath(ctx, b.x, b.y, b.w, b.h, 3);
    ctx.fill();
  }
  for(const b of eBullets){
    ctx.fillStyle = "#fde047";
    roundedRectPath(ctx, b.x, b.y, b.w, b.h, 3);
    ctx.fill();
  }
}

function drawCoins(){
  for(const c of coins){
    const scale = 0.70 + 0.30 * Math.abs(Math.sin(c.spin));
    const rx = c.r * scale;
    const ry = c.r;

    ctx.save();
    ctx.translate(c.x, c.y);
    ctx.fillStyle = "#fde047";
    ctx.beginPath();
    ctx.ellipse(0, 0, rx, ry, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = "#78350f";
    ctx.font = "900 12px Lato";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText("‚òÖ", 0, 1);
    ctx.restore();
  }
}

function drawPowers(){
  for(const p of powers){
    const scale = 0.70 + 0.30 * Math.abs(Math.sin(p.spin));
    const rx = p.r * scale;
    const ry = p.r;

    const color = (p.kind === "MAGNET") ? "#fde047" : (p.kind === "PULSE") ? "#fb7185" : "#93c5fd";
    const label = (p.kind === "MAGNET") ? "M" : (p.kind === "PULSE") ? "P" : "D";

    ctx.save();
    ctx.translate(p.x, p.y);
    ctx.fillStyle = color;
    ctx.beginPath();
    ctx.ellipse(0, 0, rx, ry, 0, 0, Math.PI*2);
    ctx.fill();
    ctx.fillStyle = "rgba(2,6,23,0.85)";
    ctx.font = "900 12px Lato";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(label, 0, 0.5);
    ctx.restore();
  }
}

function drawUfo(){
  if(!state.ufo) return;
  const u = state.ufo;
  ctx.fillStyle = "#fde047";
  roundedRectPath(ctx, u.x, u.y, u.w, u.h, 11);
  ctx.fill();
  ctx.fillStyle = "rgba(15,23,42,0.70)";
  ctx.font = "900 12px Lato";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("UFO", u.x + u.w/2, u.y + u.h/2 + 0.5);
}

function drawPauseOverlay(){
  if(!state.paused) return;
  ctx.fillStyle = "rgba(10, 15, 30, 0.55)";
  ctx.fillRect(0,0,W,H);
  ctx.fillStyle = "#f9fafb";
  ctx.font = "900 28px Lato";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("Pausa", W/2, H/2);
}

function drawGameOver(){
  ctx.fillStyle = "rgba(10, 15, 30, 0.76)";
  ctx.fillRect(0, 0, W, H);
  ctx.fillStyle = "#f9fafb";
  ctx.font = "900 30px Lato";
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  ctx.fillText("Juego terminado", W / 2, H / 2 - 20);
  ctx.font = "700 16px Lato";
  ctx.fillText(`Puntaje: ${state.score} | Nivel: ${state.level} | Oleada: ${state.wave} | Monedas: ${state.coins}`, W/2, H/2 + 18);
}

/* ---------------------------------------------------------
 *  MAIN LOOP
 * --------------------------------------------------------- */
function update(){
  state.frame++;
  if(state.shake > 0) state.shake--;
  if(state.banner > 0) state.banner--;
  if(state.swoosh > 0) state.swoosh--;
  if(state.swooshFlash > 0) state.swooshFlash--;
  if(state.chroma > 0) state.chroma--;

  if(state.playing){
    updatePlayer();
    updateInvaders();
    updateEnemyFire();
    updateUfo();

    updateCoins();
    updatePowers();
    updateDrone();

    updateBullets();
    handleCollisions();
  }

  updatePulseRings();
  updateParticles();

  if(state.frame % 12 === 0) syncHud();
}

function draw(){
  const shake = applyShake();
  ctx.save();
  ctx.clearRect(0,0,W,H);
  ctx.translate(shake.x, shake.y);

  drawBackground();

  drawUfo();
  drawInvaders();
  drawShields();
  drawPowers();
  drawCoins();
  drawPulseRings();
  drawBullets();
  drawParticles();
  drawPlayer();

  if(state.paused && state.playing) drawPauseOverlay();
  if(!state.playing) drawGameOver();

  ctx.restore();
}

function raf(){
  update();
  draw();
  requestAnimationFrame(raf);
}

/* ---------------------------------------------------------
 *  START
 * --------------------------------------------------------- */
btnPower.addEventListener("click", () => tryPulse());
btnPause.addEventListener("click", () => togglePause());
btnRestart.addEventListener("click", () => resetGame());

resetGame();
raf();

})();
</script>
</body>
</html>
